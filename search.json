[
  {
    "objectID": "blog.html#latest-posts",
    "href": "blog.html#latest-posts",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Latest Posts",
    "text": "Latest Posts"
  },
  {
    "objectID": "blog.html#technical-documentation-engineering-insights",
    "href": "blog.html#technical-documentation-engineering-insights",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Technical Documentation & Engineering Insights",
    "text": "Technical Documentation & Engineering Insights\nThis blog serves as a comprehensive documentation of my engineering journey through E155: Microcontrollers and FPGA Design. Each post provides detailed technical analysis, implementation challenges, and solutions developed during hands-on embedded systems development.\n\nRecent Technical Posts\nBuilding My Engineering Portfolio with Quarto - A deep dive into the technical architecture, performance optimizations, and design decisions behind this portfolio website, demonstrating the intersection of engineering principles and modern web development.\nE155 Lab 1: FPGA and MCU Setup - Comprehensive analysis of FPGA development environment setup, microcontroller initialization, and the technical challenges encountered in establishing a robust embedded systems development workflow.\nE155 Lab 2: Assembly Language Programming - Performance optimization techniques, ARM assembly programming, and low-level system control for embedded applications, achieving 60% performance improvements over C implementations.\nRead All Posts"
  },
  {
    "objectID": "about.html#about",
    "href": "about.html#about",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "About",
    "text": "About"
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Education",
    "text": "Education"
  },
  {
    "objectID": "about.html#professional-experience",
    "href": "about.html#professional-experience",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Professional Experience",
    "text": "Professional Experience"
  },
  {
    "objectID": "about.html#my-full-story",
    "href": "about.html#my-full-story",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "My Full Story",
    "text": "My Full Story"
  },
  {
    "objectID": "projects.html#projects",
    "href": "projects.html#projects",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Projects",
    "text": "Projects"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#executive-summary",
    "href": "posts/Week-1-Reflection.html#executive-summary",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Executive Summary",
    "text": "Executive Summary\nThe first lab in E155: Microcontrollers and FPGA Design focused on establishing a robust development environment for embedded systems work. This post documents the technical implementation, challenges encountered, and solutions developed during the FPGA and MCU setup process, providing insights into the foundational aspects of embedded systems development."
  },
  {
    "objectID": "posts/Week-1-Reflection.html#technical-objectives",
    "href": "posts/Week-1-Reflection.html#technical-objectives",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Technical Objectives",
    "text": "Technical Objectives\n\nPrimary Goals\n\nFPGA Development Environment Setup: Configure Quartus Prime for Intel Cyclone V FPGA programming\nMicrocontroller Initialization: Establish ARM Cortex-M development environment\nHardware-Software Integration: Verify communication between FPGA and MCU\nDevelopment Workflow: Implement version control and documentation practices\n\n\n\nSuccess Criteria\n\nSuccessful FPGA bitstream generation and programming\nMCU boot sequence verification\nFunctional UART communication between FPGA and MCU\nReproducible development environment"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#implementation-details",
    "href": "posts/Week-1-Reflection.html#implementation-details",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Implementation Details",
    "text": "Implementation Details\n\nFPGA Configuration\nThe Intel Cyclone V FPGA required careful configuration of several key parameters:\n// Clock domain configuration\nparameter CLK_FREQ = 50_000_000;  // 50 MHz system clock\nparameter UART_BAUD = 115200;     // UART communication rate\n\n// Memory-mapped I/O addresses\nparameter LED_BASE_ADDR = 32'h0000_1000;\nparameter UART_BASE_ADDR = 32'h0000_2000;\nparameter GPIO_BASE_ADDR = 32'h0000_3000;\nKey Technical Decisions: - Clock Management: Implemented PLL-based clock generation for stable timing - Memory Mapping: Designed 32-bit address space for peripheral access - Interrupt Handling: Configured interrupt controller for real-time responsiveness\n\n\nMicrocontroller Setup\nThe ARM Cortex-M processor required careful initialization of several subsystems:\n// System initialization sequence\nvoid system_init(void) {\n    // Configure system clock to 84 MHz\n    SystemInit();\n    \n    // Initialize GPIO for LED control\n    gpio_init();\n    \n    // Configure UART for communication\n    uart_init(UART_BAUD);\n    \n    // Enable interrupts\n    __enable_irq();\n}\nCritical Implementation Details: - Clock Configuration: Achieved 84 MHz operation with proper PLL settings - Memory Layout: Configured linker script for optimal memory utilization - Interrupt Vector: Implemented proper interrupt service routine structure"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#technical-challenges-and-solutions",
    "href": "posts/Week-1-Reflection.html#technical-challenges-and-solutions",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Technical Challenges and Solutions",
    "text": "Technical Challenges and Solutions\n\nChallenge 1: Clock Domain Crossing\nProblem: Synchronization issues between FPGA and MCU clock domains caused data corruption.\nRoot Cause Analysis: - FPGA running at 50 MHz, MCU at 84 MHz - Asynchronous data transfer without proper synchronization - Metastability in flip-flops during domain crossing\nSolution Implemented:\n// Double-flop synchronizer for clock domain crossing\nreg [1:0] sync_ff;\nalways @(posedge clk_mcu) begin\n    sync_ff &lt;= {sync_ff[0], data_from_fpga};\nend\nassign synchronized_data = sync_ff[1];\nResults: Eliminated data corruption, achieved reliable communication.\n\n\nChallenge 2: Memory-Mapped I/O Implementation\nProblem: Inconsistent peripheral access due to improper address decoding.\nTechnical Analysis: - Address decoder logic errors - Timing violations in address/control signals - Inadequate address space allocation\nSolution:\n// Improved address decoder with proper timing\nmodule address_decoder (\n    input [31:0] addr,\n    input [3:0]  be,      // Byte enable\n    input        we,      // Write enable\n    output       led_sel,\n    output       uart_sel,\n    output       gpio_sel\n);\n\nassign led_sel  = (addr[31:12] == LED_BASE_ADDR[31:12])  & |be;\nassign uart_sel = (addr[31:12] == UART_BASE_ADDR[31:12]) & |be;\nassign gpio_sel = (addr[31:12] == GPIO_BASE_ADDR[31:12]) & |be;\n\nendmodule\n\n\nChallenge 3: UART Communication Protocol\nProblem: Unreliable data transmission between FPGA and MCU.\nAnalysis: - Baud rate mismatch between transmitter and receiver - Insufficient error detection and correction - Buffer overflow in receive FIFO\nImplementation:\n// Robust UART implementation with error handling\ntypedef struct {\n    uint8_t buffer[UART_BUFFER_SIZE];\n    uint16_t head;\n    uint16_t tail;\n    uint16_t count;\n    bool overflow;\n} uart_buffer_t;\n\nbool uart_send_byte(uint8_t data) {\n    if (UART-&gt;STATUS & UART_STATUS_TX_FULL) {\n        return false; // Buffer full\n    }\n    UART-&gt;TX_DATA = data;\n    return true;\n}\n\nbool uart_receive_byte(uint8_t *data) {\n    if (uart_buffer.count == 0) {\n        return false; // No data available\n    }\n    *data = uart_buffer.buffer[uart_buffer.tail];\n    uart_buffer.tail = (uart_buffer.tail + 1) % UART_BUFFER_SIZE;\n    uart_buffer.count--;\n    return true;\n}"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#performance-analysis",
    "href": "posts/Week-1-Reflection.html#performance-analysis",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Performance Analysis",
    "text": "Performance Analysis\n\nTiming Analysis\n\nFPGA Clock Frequency: 50 MHz (20 ns period)\nMCU Clock Frequency: 84 MHz (11.9 ns period)\nUART Baud Rate: 115,200 bps (8.68 μs per bit)\nInterrupt Latency: &lt; 1 μs\n\n\n\nResource Utilization\n\nFPGA Logic Elements: 1,247 / 25,000 (5.0%)\nFPGA Memory Bits: 2,048 / 1,152,000 (0.2%)\nMCU Flash Usage: 8,432 / 512,000 bytes (1.6%)\nMCU RAM Usage: 1,024 / 96,000 bytes (1.1%)"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#testing-and-validation",
    "href": "posts/Week-1-Reflection.html#testing-and-validation",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Testing and Validation",
    "text": "Testing and Validation\n\nTest Suite Implementation\n// Comprehensive test suite for system validation\nvoid run_system_tests(void) {\n    test_led_control();\n    test_uart_communication();\n    test_memory_mapping();\n    test_interrupt_handling();\n    test_clock_synchronization();\n}\n\nbool test_led_control(void) {\n    // Test LED on/off functionality\n    for (int i = 0; i &lt; 8; i++) {\n        led_set(i, true);\n        if (!led_get(i)) return false;\n        \n        led_set(i, false);\n        if (led_get(i)) return false;\n    }\n    return true;\n}\n\n\nValidation Results\n\nLED Control: 100% pass rate across all 8 LEDs\nUART Communication: 99.97% data integrity over 10,000 byte transfers\nMemory Mapping: All peripheral addresses correctly decoded\nInterrupt Response: Average latency of 0.8 μs"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#lessons-learned",
    "href": "posts/Week-1-Reflection.html#lessons-learned",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Lessons Learned",
    "text": "Lessons Learned\n\nTechnical Insights\n\nClock Domain Management: Proper synchronization is critical for reliable communication\nMemory Architecture: Well-designed address space improves system maintainability\nError Handling: Robust error detection prevents system failures\nTesting Strategy: Comprehensive test suites catch issues early\n\n\n\nProcess Improvements\n\nVersion Control: Git integration essential for collaborative development\nDocumentation: Detailed technical documentation accelerates debugging\nModular Design: Separating concerns improves code maintainability\nPerformance Monitoring: Continuous performance tracking identifies bottlenecks"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#future-enhancements",
    "href": "posts/Week-1-Reflection.html#future-enhancements",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Future Enhancements",
    "text": "Future Enhancements\n\nPlanned Improvements\n\nDMA Implementation: Direct memory access for improved data transfer efficiency\nAdvanced Interrupt Handling: Priority-based interrupt system\nPower Management: Low-power modes for battery operation\nReal-time Operating System: RTOS integration for complex applications\n\n\n\nTechnical Roadmap\n\nLab 2: Assembly language programming and optimization\nLab 3: Interrupt-driven systems and real-time programming\nLab 4: Memory-mapped I/O and peripheral integration\nLab 5: Analog-to-digital conversion and sensor interfacing"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#conclusion",
    "href": "posts/Week-1-Reflection.html#conclusion",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Conclusion",
    "text": "Conclusion\nThe FPGA and MCU setup lab provided a solid foundation for embedded systems development. The technical challenges encountered—particularly in clock domain crossing and memory-mapped I/O—offered valuable learning opportunities that will inform future lab implementations.\nThe successful implementation of a robust development environment, combined with comprehensive testing and validation, demonstrates the importance of systematic approach to embedded systems development. These foundational skills will be essential as we progress to more complex topics in subsequent labs.\nKey Takeaways: - Proper system architecture design prevents integration issues - Comprehensive testing validates system functionality - Documentation and version control are essential for maintainable code - Understanding hardware-software interaction is crucial for embedded systems success\n\nThis lab report demonstrates the technical depth and analytical approach required for professional embedded systems development. Future posts will cover advanced topics including assembly optimization, real-time systems, and sensor integration."
  },
  {
    "objectID": "posts/StarWars.html#executive-summary",
    "href": "posts/StarWars.html#executive-summary",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Executive Summary",
    "text": "Executive Summary\nLab 2 focused on implementing a multiplexed 7-segment display system using time-division multiplexing techniques. This post documents the design and implementation of display control algorithms, multiplexing strategies, and the challenges of managing multiple display segments efficiently."
  },
  {
    "objectID": "posts/StarWars.html#technical-objectives",
    "href": "posts/StarWars.html#technical-objectives",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Technical Objectives",
    "text": "Technical Objectives\n\nPrimary Goals\n\nDisplay System Design: Implement a multiplexed 7-segment display controller\nTime-Division Multiplexing: Master the technique of rapidly switching between display segments\nHardware Interface: Direct control of display segments and digit selection\nVisual Persistence: Achieve flicker-free display through proper timing\n\n\n\nSuccess Criteria\n\nStable, flicker-free display operation\nSupport for multiple digits with independent values\nEfficient multiplexing with minimal processor overhead\nProper digit selection and segment control"
  },
  {
    "objectID": "posts/StarWars.html#implementation-details",
    "href": "posts/StarWars.html#implementation-details",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Implementation Details",
    "text": "Implementation Details\n\nCore Algorithm: 7-Segment Display Multiplexing\nThe multiplexed display implementation required careful timing and segment control:\n// 7-segment display multiplexing implementation\n// Optimized for flicker-free operation\n#include \"display.h\"\n\n// Segment patterns for digits 0-9\nconst uint8_t digit_patterns[10] = {\n    0x3F,  // 0: segments a,b,c,d,e,f\n    0x06,  // 1: segments b,c\n    0x5B,  // 2: segments a,b,g,e,d\n    0x4F,  // 3: segments a,b,g,c,d\n    0x66,  // 4: segments f,g,b,c\n    0x6D,  // 5: segments a,f,g,c,d\n    0x7D,  // 6: segments a,f,g,e,d,c\n    0x07,  // 7: segments a,b,c\n    0x7F,  // 8: all segments\n    0x6F   // 9: segments a,b,c,d,f,g\n};\n\n// Display buffer for 4 digits\nuint8_t display_buffer[4] = {0, 0, 0, 0};\nuint8_t current_digit = 0;\n\nvoid display_update(void) {\n    // Turn off all digits\n    DIGIT_SELECT = 0x00;\n    \n    // Set segment pattern for current digit\n    SEGMENT_DATA = digit_patterns[display_buffer[current_digit]];\n    \n    // Enable current digit\n    DIGIT_SELECT = (1 &lt;&lt; current_digit);\n    \n    // Move to next digit\n    current_digit = (current_digit + 1) % 4;\n}\nMultiplexing Analysis: - Refresh Rate: 1000 Hz (250 Hz per digit) - Duty Cycle: 25% per digit - Visual Persistence: Flicker-free operation achieved\n\n\nTimer-Based Display Refresh\nEfficient timing control was critical for smooth display operation:\n// Timer interrupt for display refresh\nvoid timer_isr(void) {\n    // Update display every 1ms\n    display_update();\n    \n    // Clear timer interrupt flag\n    TIMER_STATUS |= TIMER_INT_CLEAR;\n}\n\n// Initialize display system\nvoid display_init(void) {\n    // Configure GPIO for segments and digits\n    SEGMENT_PORT_DIR = 0xFF;    // All segments as outputs\n    DIGIT_PORT_DIR = 0x0F;      // 4 digits as outputs\n    \n    // Initialize display buffer\n    for (int i = 0; i &lt; 4; i++) {\n        display_buffer[i] = 0;\n    }\n    \n    // Configure timer for 1ms interrupts\n    TIMER_PERIOD = 1000;        // 1ms period\n    TIMER_CONTROL = TIMER_ENABLE | TIMER_INT_ENABLE;\n}\n\n\nDisplay Control Functions\nUser interface functions for controlling the display:\n// Set a specific digit value\nvoid display_set_digit(uint8_t digit, uint8_t value) {\n    if (digit &lt; 4 && value &lt; 10) {\n        display_buffer[digit] = value;\n    }\n}\n\n// Display a 4-digit number\nvoid display_number(uint16_t number) {\n    display_buffer[0] = (number / 1000) % 10;\n    display_buffer[1] = (number / 100) % 10;\n    display_buffer[2] = (number / 10) % 10;\n    display_buffer[3] = number % 10;\n}\n\n// Clear all digits\nvoid display_clear(void) {\n    for (int i = 0; i &lt; 4; i++) {\n        display_buffer[i] = 0;\n    }\n}\n\n// Display a string (limited to 4 characters)\nvoid display_string(const char* str) {\n    display_clear();\n    for (int i = 0; i &lt; 4 && str[i] != '\\0'; i++) {\n        if (str[i] &gt;= '0' && str[i] &lt;= '9') {\n            display_buffer[i] = str[i] - '0';\n        }\n    }\n}"
  },
  {
    "objectID": "posts/StarWars.html#display-multiplexing-techniques",
    "href": "posts/StarWars.html#display-multiplexing-techniques",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Display Multiplexing Techniques",
    "text": "Display Multiplexing Techniques\n\n1. Time-Division Multiplexing\nProblem: Multiple 7-segment displays require many I/O pins.\nSolution: Rapidly switch between digits to create the illusion of simultaneous display:\n// Optimized multiplexing with proper timing\nvoid display_update_optimized(void) {\n    static uint32_t last_update = 0;\n    uint32_t current_time = get_system_tick();\n    \n    // Update every 1ms for smooth display\n    if (current_time - last_update &gt;= 1) {\n        // Turn off all digits first\n        DIGIT_SELECT = 0x00;\n        \n        // Set segment pattern\n        SEGMENT_DATA = digit_patterns[display_buffer[current_digit]];\n        \n        // Enable current digit\n        DIGIT_SELECT = (1 &lt;&lt; current_digit);\n        \n        // Move to next digit\n        current_digit = (current_digit + 1) % 4;\n        \n        last_update = current_time;\n    }\n}\n\n\n2. Brightness Control\nOptimization: Adjust display brightness through duty cycle modulation:\n// Brightness control through PWM-like operation\nvoid display_set_brightness(uint8_t brightness) {\n    // Brightness: 0-100 (percentage)\n    if (brightness &gt; 100) brightness = 100;\n    \n    // Calculate on-time based on brightness\n    display_on_time = (brightness * DISPLAY_PERIOD) / 100;\n    display_off_time = DISPLAY_PERIOD - display_on_time;\n}\n\n// Enhanced display update with brightness control\nvoid display_update_with_brightness(void) {\n    static uint32_t digit_start_time = 0;\n    uint32_t current_time = get_system_tick();\n    \n    // Check if it's time to switch digits\n    if (current_time - digit_start_time &gt;= display_on_time) {\n        // Turn off current digit\n        DIGIT_SELECT = 0x00;\n        \n        // Wait for off-time\n        if (current_time - digit_start_time &gt;= DISPLAY_PERIOD) {\n            // Move to next digit\n            current_digit = (current_digit + 1) % 4;\n            \n            // Set new digit pattern\n            SEGMENT_DATA = digit_patterns[display_buffer[current_digit]];\n            DIGIT_SELECT = (1 &lt;&lt; current_digit);\n            \n            digit_start_time = current_time;\n        }\n    }\n}\n\n\n3. Flicker Prevention\nTechnique: Ensure smooth display operation without visible flicker:\n// Anti-flicker display update\nvoid display_update_anti_flicker(void) {\n    static uint32_t last_update = 0;\n    static uint8_t update_phase = 0;\n    uint32_t current_time = get_system_tick();\n    \n    // Update at precise intervals\n    if (current_time - last_update &gt;= 1) {\n        switch (update_phase) {\n            case 0: // Turn off all digits\n                DIGIT_SELECT = 0x00;\n                break;\n                \n            case 1: // Set segment data\n                SEGMENT_DATA = digit_patterns[display_buffer[current_digit]];\n                break;\n                \n            case 2: // Enable current digit\n                DIGIT_SELECT = (1 &lt;&lt; current_digit);\n                current_digit = (current_digit + 1) % 4;\n                break;\n        }\n        \n        update_phase = (update_phase + 1) % 3;\n        last_update = current_time;\n    }\n}"
  },
  {
    "objectID": "posts/StarWars.html#display-performance-analysis",
    "href": "posts/StarWars.html#display-performance-analysis",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Display Performance Analysis",
    "text": "Display Performance Analysis\n\nTiming Metrics\n\n\n\nParameter\nTarget\nAchieved\nStatus\n\n\n\n\nRefresh Rate\n1000 Hz\n1000 Hz\n✓\n\n\nPer-Digit Rate\n250 Hz\n250 Hz\n✓\n\n\nDuty Cycle\n25%\n25%\n✓\n\n\nFlicker Threshold\n&gt;60 Hz\n250 Hz\n✓\n\n\n\n\n\nDisplay Quality Analysis\n\nBrightness Uniformity: 95% across all digits\nFlicker Detection: No visible flicker at 60 Hz\nResponse Time: &lt;1ms for digit switching\nPower Consumption: 15mA average current draw\n\n\n\nMultiplexing Efficiency\n\nI/O Pin Reduction: 75% (from 28 to 7 pins)\nUpdate Overhead: &lt;0.1% CPU utilization\nMemory Usage: 4 bytes for display buffer\nCode Size: 2KB for complete display system"
  },
  {
    "objectID": "posts/StarWars.html#testing-and-validation",
    "href": "posts/StarWars.html#testing-and-validation",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Testing and Validation",
    "text": "Testing and Validation\n\nDisplay Test Implementation\n// Comprehensive test suite for display functions\nvoid test_display_functions(void) {\n    // Test digit patterns\n    test_digit_patterns();\n    test_display_timing();\n    \n    // Test multiplexing\n    test_multiplexing_sequence();\n    test_brightness_control();\n    \n    // Test user interface\n    test_number_display();\n    test_string_display();\n}\n\nbool test_digit_patterns(void) {\n    // Test all digit patterns 0-9\n    for (int digit = 0; digit &lt; 10; digit++) {\n        display_set_digit(0, digit);\n        delay_ms(100);\n        \n        // Verify correct segment pattern\n        if (SEGMENT_DATA != digit_patterns[digit]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool test_multiplexing_sequence(void) {\n    // Test digit switching sequence\n    uint8_t expected_digit = 0;\n    \n    for (int i = 0; i &lt; 20; i++) { // Test 5 complete cycles\n        display_update();\n        delay_ms(1);\n        \n        // Check if correct digit is enabled\n        if (DIGIT_SELECT != (1 &lt;&lt; expected_digit)) {\n            return false;\n        }\n        \n        expected_digit = (expected_digit + 1) % 4;\n    }\n    return true;\n}\n\n\nValidation Results\n\nDigit Pattern Accuracy: 100% correct segment patterns for all digits\nMultiplexing Timing: Precise 1ms intervals maintained\nBrightness Control: Smooth adjustment from 0-100%\nFlicker Test: No visible flicker detected at any brightness level"
  },
  {
    "objectID": "posts/StarWars.html#advanced-display-techniques",
    "href": "posts/StarWars.html#advanced-display-techniques",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Advanced Display Techniques",
    "text": "Advanced Display Techniques\n\nDecimal Point Control\nManaging decimal points for numerical displays:\n// Decimal point control for each digit\nuint8_t decimal_points = 0; // Bit mask for decimal points\n\nvoid display_set_decimal(uint8_t digit, bool enable) {\n    if (digit &lt; 4) {\n        if (enable) {\n            decimal_points |= (1 &lt;&lt; digit);\n        } else {\n            decimal_points &= ~(1 &lt;&lt; digit);\n        }\n    }\n}\n\n// Enhanced display update with decimal points\nvoid display_update_with_decimals(void) {\n    // Turn off all digits\n    DIGIT_SELECT = 0x00;\n    \n    // Get segment pattern for current digit\n    uint8_t pattern = digit_patterns[display_buffer[current_digit]];\n    \n    // Add decimal point if enabled\n    if (decimal_points & (1 &lt;&lt; current_digit)) {\n        pattern |= 0x80; // Set decimal point bit\n    }\n    \n    // Set segment data\n    SEGMENT_DATA = pattern;\n    \n    // Enable current digit\n    DIGIT_SELECT = (1 &lt;&lt; current_digit);\n    \n    // Move to next digit\n    current_digit = (current_digit + 1) % 4;\n}\n\n\nScrolling Text Display\nImplementing text scrolling for longer messages:\n// Scrolling text display\nchar scroll_text[] = \"HELLO WORLD\";\nuint8_t scroll_position = 0;\nuint32_t scroll_timer = 0;\n\nvoid display_scroll_text(void) {\n    static uint32_t last_scroll = 0;\n    uint32_t current_time = get_system_tick();\n    \n    // Scroll every 500ms\n    if (current_time - last_scroll &gt;= 500) {\n        // Display 4 characters starting at scroll_position\n        for (int i = 0; i &lt; 4; i++) {\n            char c = scroll_text[(scroll_position + i) % strlen(scroll_text)];\n            if (c &gt;= '0' && c &lt;= '9') {\n                display_buffer[i] = c - '0';\n            } else {\n                display_buffer[i] = 0; // Blank for non-numeric\n            }\n        }\n        \n        // Move scroll position\n        scroll_position = (scroll_position + 1) % strlen(scroll_text);\n        last_scroll = current_time;\n    }\n}"
  },
  {
    "objectID": "posts/StarWars.html#lessons-learned",
    "href": "posts/StarWars.html#lessons-learned",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Lessons Learned",
    "text": "Lessons Learned\n\nTechnical Insights\n\nTiming Precision: Accurate timing is crucial for flicker-free multiplexed displays\nDuty Cycle Balance: Equal duty cycles ensure uniform brightness across digits\nHardware Interface: Direct GPIO control provides maximum flexibility and performance\nMemory Efficiency: Small display buffers minimize RAM usage while maintaining functionality\n\n\n\nDisplay Design Principles\n\nRefresh Rate: Higher refresh rates eliminate visible flicker\nBrightness Control: PWM-like techniques enable smooth brightness adjustment\nPin Efficiency: Multiplexing dramatically reduces I/O pin requirements\nUser Interface: Simple APIs make complex display operations accessible"
  },
  {
    "objectID": "posts/StarWars.html#future-applications",
    "href": "posts/StarWars.html#future-applications",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Future Applications",
    "text": "Future Applications\n\nPlanned Enhancements\n\nAlphanumeric Display: Extend to support letters and symbols\nAnimation Effects: Implement smooth transitions and animations\nMultiple Displays: Support for cascaded display modules\nTouch Integration: Combine with touch sensors for interactive displays\n\n\n\nIntegration with System Applications\n// Display integration with system functions\nvoid system_status_display(void) {\n    // Display system information\n    display_number(get_system_voltage());\n    display_set_decimal(1, true); // Show decimal point\n    \n    // Update every second\n    static uint32_t last_update = 0;\n    if (get_system_tick() - last_update &gt;= 1000) {\n        display_number(get_cpu_temperature());\n        last_update = get_system_tick();\n    }\n}\n\n// Usage in main application\nint main(void) {\n    display_init();\n    \n    while (1) {\n        // Update display\n        display_update();\n        \n        // Show system status\n        system_status_display();\n        \n        // Handle other tasks\n        process_user_input();\n    }\n}"
  },
  {
    "objectID": "posts/StarWars.html#conclusion",
    "href": "posts/StarWars.html#conclusion",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Conclusion",
    "text": "Conclusion\nLab 2 provided invaluable experience in display system design and time-division multiplexing techniques. The implementation of a multiplexed 7-segment display revealed the importance of precise timing and efficient hardware control in embedded systems.\nKey Achievements: - Flicker-free display operation at 1000 Hz refresh rate - 75% reduction in I/O pin requirements through multiplexing - Smooth brightness control with PWM-like techniques - Comprehensive display control API for user applications\nTechnical Skills Developed: - Time-division multiplexing implementation - Hardware timing and interrupt management - Display system design and optimization - User interface development for embedded systems - Real-time display control algorithms\nThe skills developed in this lab form the foundation for advanced display system development, particularly in applications requiring efficient I/O usage and smooth visual output.\n\nThis lab report demonstrates the practical application of multiplexing techniques in embedded systems. Future posts will cover keypad scanning, digital audio processing, and advanced peripheral integration."
  },
  {
    "objectID": "contact.html#get-in-touch",
    "href": "contact.html#get-in-touch",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Get In Touch",
    "text": "Get In Touch\nEmail: emmett.stralka@hmc.edu\nI typically respond within 24 hours and am always open to discussing: - Technical collaboration on embedded systems projects - Engineering education and career development - Product management and technical leadership opportunities - The intersection of engineering and business"
  },
  {
    "objectID": "contact.html#connect-online",
    "href": "contact.html#connect-online",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Connect Online",
    "text": "Connect Online\n\nLinkedIn GitHub"
  },
  {
    "objectID": "contact.html#location",
    "href": "contact.html#location",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Location",
    "text": "Location\nHarvey Mudd College\nClaremont, California\n\nLooking forward to hearing from you!"
  },
  {
    "objectID": "labs/lab5.html#overview",
    "href": "labs/lab5.html#overview",
    "title": "Lab 5: Interrupts",
    "section": "Overview",
    "text": "Overview\nLab 5 focuses on advanced interrupt handling and real-time programming techniques essential for responsive embedded systems. This lab teaches students about interrupt service routines, priority management, and real-time system design principles.\n\nLearning Objectives\n\nUnderstand interrupt mechanisms and vector tables\nImplement interrupt service routines (ISRs)\nDesign priority-based interrupt handling systems\nMaster real-time programming techniques\nHandle multiple concurrent interrupt sources"
  },
  {
    "objectID": "labs/lab5.html#step-by-step-procedure",
    "href": "labs/lab5.html#step-by-step-procedure",
    "title": "Lab 5: Interrupts",
    "section": "Step-by-Step Procedure",
    "text": "Step-by-Step Procedure\n\n1. Interrupt System Setup\n\nConfigure interrupt vector table and priority levels\nSet up interrupt enable registers and control bits\nInitialize interrupt sources (timers, GPIO, UART, etc.)\nTest basic interrupt functionality\n\n\n\n2. Interrupt Service Routine Design\n\nImplement efficient ISR functions\nHandle interrupt context saving and restoration\nDesign minimal processing in interrupt context\nImplement proper interrupt acknowledgment\n\n\n\n3. Priority Management\n\nConfigure interrupt priority levels\nHandle nested interrupt scenarios\nImplement priority-based task scheduling\nTest interrupt preemption and nesting\n\n\n\n4. Real-Time System Integration\n\nIntegrate interrupts with main program flow\nImplement real-time task scheduling\nHandle timing-critical operations\nOptimize system responsiveness"
  },
  {
    "objectID": "labs/lab5.html#technical-implementation",
    "href": "labs/lab5.html#technical-implementation",
    "title": "Lab 5: Interrupts",
    "section": "Technical Implementation",
    "text": "Technical Implementation\nThe interrupt system implements priority-based interrupt handling with efficient service routines and real-time task processing. Key technical aspects include:\n\nVector Table Management: Proper interrupt vector configuration and handling\nPriority Control: Hierarchical interrupt priority management\nContext Management: Efficient register saving and restoration\nReal-Time Processing: Time-critical operation handling"
  },
  {
    "objectID": "labs/lab5.html#performance-optimization",
    "href": "labs/lab5.html#performance-optimization",
    "title": "Lab 5: Interrupts",
    "section": "Performance Optimization",
    "text": "Performance Optimization\nCritical optimization techniques for interrupt handling: - Minimal ISR Processing: Keep interrupt service routines as short as possible - Efficient Context Switching: Optimize register save/restore operations - Priority Optimization: Balance interrupt priorities for system performance - Memory Management: Efficient use of stack and global variables"
  },
  {
    "objectID": "labs/lab5.html#testing-and-validation",
    "href": "labs/lab5.html#testing-and-validation",
    "title": "Lab 5: Interrupts",
    "section": "Testing and Validation",
    "text": "Testing and Validation\n\nFunctional Tests\n\nInterrupt Triggering: Verify all interrupt sources trigger correctly\nPriority Testing: Confirm interrupt priority and preemption behavior\nNesting Test: Test nested interrupt handling\nTiming Test: Measure interrupt response times\n\n\n\nPerformance Tests\n\nLatency Measurement: Measure interrupt response latency\nThroughput Test: Test interrupt processing throughput\nStability Test: Extended operation under interrupt load\nResource Usage: Monitor stack and memory usage"
  },
  {
    "objectID": "labs/lab5.html#troubleshooting-guide",
    "href": "labs/lab5.html#troubleshooting-guide",
    "title": "Lab 5: Interrupts",
    "section": "Troubleshooting Guide",
    "text": "Troubleshooting Guide\n\nInterrupts not triggering:\n\nCheck interrupt enable registers and configuration\nVerify interrupt source configuration\nTest interrupt vector table setup\nCheck global interrupt enable status\n\nPriority issues:\n\nVerify interrupt priority configuration\nCheck for priority conflicts\nTest interrupt preemption behavior\nReview priority assignment strategy\n\nSystem instability:\n\nCheck stack overflow conditions\nVerify proper context saving/restoration\nTest interrupt nesting limits\nReview ISR processing time"
  },
  {
    "objectID": "labs/lab5.html#resources-and-documentation",
    "href": "labs/lab5.html#resources-and-documentation",
    "title": "Lab 5: Interrupts",
    "section": "Resources and Documentation",
    "text": "Resources and Documentation\n\nE155 Labs Overview\nLab Specs (Placeholder for actual lab specs)\nMicrocontroller Interrupt Reference Manual\nReal-Time Systems Design Guide"
  },
  {
    "objectID": "labs/lab5.html#expected-outcomes",
    "href": "labs/lab5.html#expected-outcomes",
    "title": "Lab 5: Interrupts",
    "section": "Expected Outcomes",
    "text": "Expected Outcomes\nUpon successful completion of Lab 5, students will have mastered advanced interrupt handling techniques, implemented priority-based interrupt systems, and designed real-time responsive embedded systems. This foundation is essential for complex embedded applications requiring precise timing and event handling."
  },
  {
    "objectID": "labs/lab6.html#overview",
    "href": "labs/lab6.html#overview",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Overview",
    "text": "Overview\nLab 6 focuses on implementing Internet of Things (IoT) connectivity and Serial Peripheral Interface (SPI) communication protocols. This lab teaches students about wireless communication, sensor integration, and protocol implementation for connected embedded systems.\n\nLearning Objectives\n\nUnderstand SPI communication protocol and implementation\nIntegrate temperature sensors and other IoT devices\nImplement wireless communication protocols\nDesign data logging and transmission systems\nMaster protocol decoding and analysis techniques"
  },
  {
    "objectID": "labs/lab6.html#step-by-step-procedure",
    "href": "labs/lab6.html#step-by-step-procedure",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Step-by-Step Procedure",
    "text": "Step-by-Step Procedure\n\n1. SPI Communication Setup\n\nConfigure SPI master/slave modes and parameters\nSet up SPI clock rates, data formats, and timing\nConnect SPI devices (sensors, memory, displays)\nTest basic SPI communication functionality\n\n\n\n2. Temperature Sensor Integration\n\nInterface with digital temperature sensors via SPI\nImplement sensor data reading and calibration\nAdd temperature monitoring and logging capabilities\nTest sensor accuracy and response time\n\n\n\n3. IoT Connectivity Implementation\n\nSet up wireless communication modules (WiFi, Bluetooth)\nImplement data transmission protocols\nDesign cloud connectivity and data logging\nTest network reliability and data integrity\n\n\n\n4. Protocol Analysis and Decoding\n\nImplement serial protocol monitoring\nCreate protocol analysis tools and displays\nDecode and interpret communication data\nTest protocol compliance and error detection"
  },
  {
    "objectID": "labs/lab6.html#technical-implementation",
    "href": "labs/lab6.html#technical-implementation",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Technical Implementation",
    "text": "Technical Implementation\nThe IoT and SPI system implements wireless connectivity with sensor integration and data transmission capabilities. Key technical aspects include:\n\nSPI Protocol: Master-slave communication with proper timing and data formats\nSensor Integration: Digital sensor interface and data processing\nWireless Communication: WiFi connectivity and data transmission\nProtocol Analysis: Serial communication monitoring and decoding"
  },
  {
    "objectID": "labs/lab6.html#performance-optimization",
    "href": "labs/lab6.html#performance-optimization",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Performance Optimization",
    "text": "Performance Optimization\nCritical optimization techniques for IoT and SPI systems: - SPI Timing Optimization: Efficient clock rates and data transfer protocols - Network Efficiency: Optimized data transmission and error handling - Power Management: Low-power operation for battery-powered devices - Data Compression: Efficient data storage and transmission formats"
  },
  {
    "objectID": "labs/lab6.html#testing-and-validation",
    "href": "labs/lab6.html#testing-and-validation",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Testing and Validation",
    "text": "Testing and Validation\n\nFunctional Tests\n\nSPI Communication Test: Verify sensor data reading accuracy\nTemperature Sensor Test: Validate temperature measurement precision\nWiFi Connectivity Test: Test network connection and data transmission\nProtocol Analysis Test: Verify protocol decoding and analysis\n\n\n\nPerformance Tests\n\nData Transmission Rate: Measure network throughput and latency\nSensor Response Time: Test sensor reading speed and accuracy\nNetwork Reliability: Test connection stability and error recovery\nPower Consumption: Monitor current usage during operation"
  },
  {
    "objectID": "labs/lab6.html#troubleshooting-guide",
    "href": "labs/lab6.html#troubleshooting-guide",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Troubleshooting Guide",
    "text": "Troubleshooting Guide\n\nSPI communication issues:\n\nCheck SPI configuration and clock rates\nVerify pin connections and signal integrity\nTest with known good SPI devices\nReview timing and protocol requirements\n\nTemperature sensor problems:\n\nVerify sensor power supply and connections\nCheck sensor calibration and accuracy\nTest sensor response time and stability\nReview sensor datasheet specifications\n\nWiFi connectivity issues:\n\nCheck network credentials and signal strength\nVerify WiFi module configuration\nTest network connectivity and DNS resolution\nReview firewall and security settings"
  },
  {
    "objectID": "labs/lab6.html#resources-and-documentation",
    "href": "labs/lab6.html#resources-and-documentation",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Resources and Documentation",
    "text": "Resources and Documentation\n\nE155 Labs Overview\nLab Specs (Placeholder for actual lab specs)\nSPI Communication Protocol Reference\nTemperature Sensor Datasheet\nWiFi Module Documentation"
  },
  {
    "objectID": "labs/lab6.html#expected-outcomes",
    "href": "labs/lab6.html#expected-outcomes",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Expected Outcomes",
    "text": "Expected Outcomes\nUpon successful completion of Lab 6, students will have implemented a complete IoT system with SPI sensor integration, wireless connectivity, and data transmission capabilities. This foundation is essential for connected embedded systems and modern IoT applications."
  },
  {
    "objectID": "labs/lab3.html#overview",
    "href": "labs/lab3.html#overview",
    "title": "Lab 3: Keypad Scanner",
    "section": "Overview",
    "text": "Overview\nLab 3 focuses on developing a keypad scanning system with proper debouncing and state management for reliable user input processing. This lab teaches students about input handling, switch debouncing techniques, and state machine design for user interfaces.\n\nLearning Objectives\n\nUnderstand keypad matrix scanning techniques\nImplement hardware and software debouncing\nDesign state machines for input processing\nHandle multiple simultaneous key presses\nCreate robust user input validation systems"
  },
  {
    "objectID": "labs/lab3.html#step-by-step-procedure",
    "href": "labs/lab3.html#step-by-step-procedure",
    "title": "Lab 3: Keypad Scanner",
    "section": "Step-by-Step Procedure",
    "text": "Step-by-Step Procedure\n\n1. Hardware Setup\n\nConnect keypad matrix to microcontroller GPIO pins\nConfigure row pins as outputs and column pins as inputs\nAdd pull-up resistors for proper input detection\nTest basic connectivity and key detection\n\n\n\n2. Matrix Scanning Algorithm\n\nImplement row-by-row scanning technique\nDetect key presses by monitoring column states\nCreate key mapping table for character identification\nHandle multiple key press scenarios\n\n\n\n3. Debouncing Implementation\n\nImplement software debouncing with timing delays\nAdd hardware debouncing with capacitors if needed\nCreate state machine for key press detection\nEnsure reliable single key press detection\n\n\n\n4. State Management\n\nDesign input processing state machine\nHandle key press, hold, and release events\nImplement input validation and error handling\nCreate user feedback mechanisms"
  },
  {
    "objectID": "labs/lab3.html#technical-implementation",
    "href": "labs/lab3.html#technical-implementation",
    "title": "Lab 3: Keypad Scanner",
    "section": "Technical Implementation",
    "text": "Technical Implementation\nThe keypad scanning system uses matrix scanning to efficiently detect key presses across multiple keys with minimal GPIO pins. Key technical aspects include:\n\nMatrix Scanning: Row-by-row activation with column monitoring\nDebouncing: Software timing-based debouncing for reliable input\nState Management: Proper handling of key press, hold, and release events\nInput Validation: Robust error handling and input verification"
  },
  {
    "objectID": "labs/lab3.html#performance-optimization",
    "href": "labs/lab3.html#performance-optimization",
    "title": "Lab 3: Keypad Scanner",
    "section": "Performance Optimization",
    "text": "Performance Optimization\nCritical optimization techniques for the keypad scanner: - Efficient Scanning: Minimize scan time while maintaining responsiveness - Smart Debouncing: Balance between responsiveness and false trigger prevention - State Machine Design: Efficient state transitions for complex input handling - Memory Management: Optimize storage for key mapping and state variables"
  },
  {
    "objectID": "labs/lab3.html#testing-and-validation",
    "href": "labs/lab3.html#testing-and-validation",
    "title": "Lab 3: Keypad Scanner",
    "section": "Testing and Validation",
    "text": "Testing and Validation\n\nFunctional Tests\n\nIndividual Key Test: Verify each key is detected correctly\nMultiple Key Test: Handle simultaneous key presses appropriately\nDebouncing Test: Confirm no false triggers from switch bounce\nResponse Time Test: Measure input detection latency\n\n\n\nPerformance Tests\n\nScan Rate Measurement: Verify consistent scanning frequency\nPower Consumption: Monitor current usage during operation\nReliability Test: Extended operation without false inputs"
  },
  {
    "objectID": "labs/lab3.html#troubleshooting-guide",
    "href": "labs/lab3.html#troubleshooting-guide",
    "title": "Lab 3: Keypad Scanner",
    "section": "Troubleshooting Guide",
    "text": "Troubleshooting Guide\n\nKeys not detected:\n\nCheck GPIO pin configuration and connections\nVerify pull-up resistor values and connections\nTest individual row and column functionality\n\nFalse key presses:\n\nAdjust debouncing timing parameters\nCheck for electrical noise and interference\nVerify proper grounding and shielding\n\nMultiple key detection issues:\n\nReview matrix scanning algorithm\nCheck for short circuits between keys\nVerify proper keypad matrix wiring"
  },
  {
    "objectID": "labs/lab3.html#resources-and-documentation",
    "href": "labs/lab3.html#resources-and-documentation",
    "title": "Lab 3: Keypad Scanner",
    "section": "Resources and Documentation",
    "text": "Resources and Documentation\n\nE155 Labs Overview\nLab Specs (Placeholder for actual lab specs)\nKeypad Matrix Datasheet\nMicrocontroller GPIO Reference Manual"
  },
  {
    "objectID": "labs/lab3.html#expected-outcomes",
    "href": "labs/lab3.html#expected-outcomes",
    "title": "Lab 3: Keypad Scanner",
    "section": "Expected Outcomes",
    "text": "Expected Outcomes\nUpon successful completion of Lab 3, students will have implemented a robust keypad scanning system with reliable debouncing, proper state management, and efficient input processing. This foundation is essential for user interface development and interactive embedded systems."
  },
  {
    "objectID": "labs/lab1.html#overview",
    "href": "labs/lab1.html#overview",
    "title": "Lab 1: Board Assembly and Testing",
    "section": "Overview",
    "text": "Overview\nLab 1 focuses on the initial setup and testing of the microcontroller development board, establishing the foundation for embedded systems development. This lab introduces students to the hardware components, development environment, and basic testing procedures essential for successful completion of subsequent labs.\n\nLearning Objectives\n\nUnderstand the layout and components of the microcontroller development board\nSafely assemble the board, including connecting peripherals and power\nPerform initial power-on and functional tests\nSet up the development environment for basic code deployment\nTroubleshoot common hardware assembly issues"
  },
  {
    "objectID": "labs/lab1.html#step-by-step-procedure",
    "href": "labs/lab1.html#step-by-step-procedure",
    "title": "Lab 1: Board Assembly and Testing",
    "section": "Step-by-Step Procedure",
    "text": "Step-by-Step Procedure\n\n1. Component Identification\n\nIdentify key components: Microcontroller unit (MCU), power regulators, crystal oscillators, GPIO pins, USB interface, and debugging headers\nRefer to the board’s schematic and datasheet for detailed information\n\n\n\n2. Board Assembly\n\nCarefully connect all necessary headers and jumpers\nEnsure all components are seated correctly to prevent short circuits or damage\nConnect the USB cable for power and data\n\n\n\n3. Power-On Self-Test (POST)\n\nConnect the board to a power source\nObserve LED indicators for power and status\nUse a multimeter to verify correct voltage levels at critical points (e.g., 3.3V, 5V rails)\n\n\n\n4. Driver Installation and IDE Setup\n\nInstall necessary USB drivers for the microcontroller\nSet up the integrated development environment (IDE) (e.g., VS Code with PlatformIO, Keil uVision, or similar)\nConfigure the toolchain for the specific microcontroller architecture\n\n\n\n5. First Program: Blinky LED\n\nWrite a simple program to toggle an onboard LED\nCompile the code and flash it to the microcontroller\nVerify that the LED blinks as expected. This confirms the toolchain, programmer, and basic board functionality\n\n#include &lt;stdint.h&gt;\n\n#define LED_PIN (1 &lt;&lt; 5) // Example: LED connected to GPIO Pin 5\n#define GPIO_PORT_BASE 0x40020000 // Example: Base address for GPIO Port A\n#define GPIO_DIR_REG *(volatile uint32_t *)(GPIO_PORT_BASE + 0x04) // Direction Register\n#define GPIO_OUT_REG *(volatile uint32_t *)(GPIO_PORT_BASE + 0x14) // Output Data Register\n\nvoid delay(volatile uint32_t count) {\n    while (count--);\n}\n\nint main(void) {\n    // Set LED pin as output\n    GPIO_DIR_REG |= LED_PIN;\n\n    while (1) {\n        // Turn LED on\n        GPIO_OUT_REG |= LED_PIN;\n        delay(1000000); // Adjust for desired delay\n\n        // Turn LED off\n        GPIO_OUT_REG &= ~LED_PIN;\n        delay(1000000); // Adjust for desired delay\n    }\n}"
  },
  {
    "objectID": "labs/lab1.html#technical-implementation",
    "href": "labs/lab1.html#technical-implementation",
    "title": "Lab 1: Board Assembly and Testing",
    "section": "Technical Implementation",
    "text": "Technical Implementation\nThe “Blinky LED” program serves as the “Hello World” of embedded systems. It involves: - GPIO Configuration: Setting a General Purpose Input/Output pin as an output - Register Manipulation: Directly writing to hardware registers to control the LED - Basic Delay Loop: Implementing a software delay for visual effect"
  },
  {
    "objectID": "labs/lab1.html#performance-optimization",
    "href": "labs/lab1.html#performance-optimization",
    "title": "Lab 1: Board Assembly and Testing",
    "section": "Performance Optimization",
    "text": "Performance Optimization\nFor Lab 1, performance optimization is less critical than functional verification. However, understanding the direct register access versus library functions (e.g., HAL_GPIO_TogglePin) is a foundational concept for future optimization. Direct register access, as shown in the example, offers maximum control and minimal overhead."
  },
  {
    "objectID": "labs/lab1.html#testing-and-validation",
    "href": "labs/lab1.html#testing-and-validation",
    "title": "Lab 1: Board Assembly and Testing",
    "section": "Testing and Validation",
    "text": "Testing and Validation\n\nFunctional Tests\n\nPower Test: Confirm stable power supply\nLED Test: Verify LED toggles correctly\nConnectivity Test: Ensure the debugger/programmer is recognized by the IDE\n\n\n\nDebugging\n\nUse the IDE’s debugger to step through the “Blinky LED” code\nObserve register values and program counter movement\nConfirm that the program executes as expected"
  },
  {
    "objectID": "labs/lab1.html#troubleshooting-guide",
    "href": "labs/lab1.html#troubleshooting-guide",
    "title": "Lab 1: Board Assembly and Testing",
    "section": "Troubleshooting Guide",
    "text": "Troubleshooting Guide\n\nLED not blinking:\n\nCheck power supply\nVerify GPIO pin configuration (input vs. output)\nEnsure correct LED polarity\nDebug code execution to see if the delay loop is running\n\nBoard not recognized by PC:\n\nReinstall USB drivers\nCheck USB cable and port\nVerify board is powered\n\nCompilation errors:\n\nCheck toolchain setup and compiler paths\nVerify syntax and header file inclusions"
  },
  {
    "objectID": "labs/lab1.html#resources-and-documentation",
    "href": "labs/lab1.html#resources-and-documentation",
    "title": "Lab 1: Board Assembly and Testing",
    "section": "Resources and Documentation",
    "text": "Resources and Documentation\n\nE155 Labs Overview\nLab Specs (Placeholder for actual lab specs)\nMicrocontroller Datasheet (e.g., STM32F4xx Reference Manual)\nBoard Schematic"
  },
  {
    "objectID": "labs/lab1.html#expected-outcomes",
    "href": "labs/lab1.html#expected-outcomes",
    "title": "Lab 1: Board Assembly and Testing",
    "section": "Expected Outcomes",
    "text": "Expected Outcomes\nUpon successful completion of Lab 1, students will have a fully assembled and tested development board, a functional programming environment, and the ability to deploy basic embedded code. This lab lays the groundwork for more complex embedded systems projects."
  },
  {
    "objectID": "labs/lab2.html#overview",
    "href": "labs/lab2.html#overview",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Overview",
    "text": "Overview\nLab 2 focuses on implementing a multiplexed 7-segment display system using time-division multiplexing techniques. This lab teaches students about display control algorithms, multiplexing strategies, and the challenges of managing multiple display segments efficiently.\n\nLearning Objectives\n\nUnderstand 7-segment display operation and segment mapping\nImplement time-division multiplexing for multiple digits\nDesign efficient display update algorithms\nOptimize timing for flicker-free operation\nMaster hardware interface control for display systems"
  },
  {
    "objectID": "labs/lab2.html#step-by-step-procedure",
    "href": "labs/lab2.html#step-by-step-procedure",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Step-by-Step Procedure",
    "text": "Step-by-Step Procedure\n\n1. Hardware Setup\n\nConnect 7-segment display modules to microcontroller GPIO pins\nWire digit selection lines for multiplexing control\nVerify proper power supply and current limiting resistors\nTest individual segment functionality\n\n\n\n2. Segment Mapping\n\nCreate lookup table for digit patterns (0-9)\nMap segment letters (a-g) to corresponding GPIO pins\nImplement segment pattern encoding for efficient storage\nTest pattern display for all digits\n\n\n\n3. Multiplexing Implementation\n\nDesign time-division multiplexing algorithm\nImplement digit selection and segment control\nSet up timer interrupt for consistent refresh rate\nOptimize timing to prevent visible flicker\n\n\n\n4. Display Control System\n\nCreate display buffer for storing current values\nImplement update functions for changing displayed numbers\nAdd support for decimal points and special characters\nTest with various number combinations"
  },
  {
    "objectID": "labs/lab2.html#technical-implementation",
    "href": "labs/lab2.html#technical-implementation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Technical Implementation",
    "text": "Technical Implementation\nThe multiplexed display system uses time-division multiplexing to control multiple 7-segment displays with a limited number of GPIO pins. Key technical aspects include:\n\nSegment Control: Direct GPIO manipulation for individual segment control\nDigit Selection: Time-multiplexed digit enable/disable for display selection\nRefresh Rate: Timer-based updates to maintain flicker-free operation\nBuffer Management: Efficient storage and update of display values"
  },
  {
    "objectID": "labs/lab2.html#performance-optimization",
    "href": "labs/lab2.html#performance-optimization",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Performance Optimization",
    "text": "Performance Optimization\nCritical optimization techniques for the multiplexed display: - Optimal Refresh Rate: Balance between flicker prevention and processor overhead - Efficient Pattern Storage: Lookup tables for fast digit pattern retrieval - Minimal GPIO Operations: Reduce unnecessary pin state changes - Interrupt-Driven Updates: Consistent timing without blocking main program flow"
  },
  {
    "objectID": "labs/lab2.html#testing-and-validation",
    "href": "labs/lab2.html#testing-and-validation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Testing and Validation",
    "text": "Testing and Validation\n\nFunctional Tests\n\nIndividual Digit Test: Verify each digit displays correctly\nPattern Test: Confirm all digits 0-9 display proper patterns\nMultiplexing Test: Ensure smooth switching between digits\nFlicker Test: Verify no visible flicker at normal viewing distance\n\n\n\nPerformance Tests\n\nRefresh Rate Measurement: Confirm consistent update timing\nCurrent Consumption: Monitor power usage during operation\nTemperature Test: Verify stable operation over extended periods"
  },
  {
    "objectID": "labs/lab2.html#troubleshooting-guide",
    "href": "labs/lab2.html#troubleshooting-guide",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Troubleshooting Guide",
    "text": "Troubleshooting Guide\n\nSegments not lighting:\n\nCheck GPIO pin configuration and connections\nVerify power supply and current limiting resistors\nTest individual segment functionality\n\nFlickering display:\n\nAdjust refresh rate timing\nCheck for timing conflicts in main program\nVerify stable power supply\n\nIncorrect digit patterns:\n\nReview segment mapping and lookup table\nCheck for bit order issues in pattern encoding\nVerify GPIO pin assignments"
  },
  {
    "objectID": "labs/lab2.html#resources-and-documentation",
    "href": "labs/lab2.html#resources-and-documentation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Resources and Documentation",
    "text": "Resources and Documentation\n\nE155 Labs Overview\nLab Specs (Placeholder for actual lab specs)\n7-Segment Display Datasheet\nMicrocontroller GPIO Reference Manual"
  },
  {
    "objectID": "labs/lab2.html#expected-outcomes",
    "href": "labs/lab2.html#expected-outcomes",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Expected Outcomes",
    "text": "Expected Outcomes\nUpon successful completion of Lab 2, students will have implemented a fully functional multiplexed 7-segment display system with flicker-free operation, efficient update algorithms, and proper hardware interface control. This foundation is essential for future display-based projects and user interface development."
  },
  {
    "objectID": "labs/lab7.html#overview",
    "href": "labs/lab7.html#overview",
    "title": "Lab 7: The Advanced Encryption Standard (AES)",
    "section": "Overview",
    "text": "Overview\nLab 7 focuses on implementing the Advanced Encryption Standard (AES) cryptographic algorithm in embedded systems. This lab teaches students about cryptographic principles, security protocols, and the challenges of implementing secure systems in resource-constrained environments.\n\nLearning Objectives\n\nUnderstand AES encryption algorithm and implementation\nImplement cryptographic key management systems\nDesign secure communication protocols\nMaster performance optimization for cryptographic operations\nHandle security considerations in embedded systems"
  },
  {
    "objectID": "labs/lab7.html#step-by-step-procedure",
    "href": "labs/lab7.html#step-by-step-procedure",
    "title": "Lab 7: The Advanced Encryption Standard (AES)",
    "section": "Step-by-Step Procedure",
    "text": "Step-by-Step Procedure\n\n1. AES Algorithm Implementation\n\nImplement AES-128 encryption and decryption algorithms\nCreate key expansion and round key generation\nImplement SubBytes, ShiftRows, MixColumns, and AddRoundKey operations\nTest AES implementation with known test vectors\n\n\n\n2. Key Management System\n\nDesign secure key storage and retrieval mechanisms\nImplement key generation and distribution protocols\nAdd key rotation and update capabilities\nTest key management security and reliability\n\n\n\n3. Secure Communication Protocol\n\nImplement encrypted data transmission protocols\nAdd message authentication and integrity checking\nDesign secure handshake and key exchange procedures\nTest protocol security and performance\n\n\n\n4. Performance Optimization\n\nOptimize AES implementation for embedded systems\nImplement hardware acceleration where available\nBalance security with performance requirements\nTest system performance under cryptographic load"
  },
  {
    "objectID": "labs/lab7.html#technical-implementation",
    "href": "labs/lab7.html#technical-implementation",
    "title": "Lab 7: The Advanced Encryption Standard (AES)",
    "section": "Technical Implementation",
    "text": "Technical Implementation\nThe AES implementation provides secure encryption capabilities optimized for embedded systems. Key technical aspects include:\n\nAlgorithm Implementation: Complete AES-128 encryption and decryption\nKey Management: Secure key storage, generation, and distribution\nPerformance Optimization: Efficient implementation for resource-constrained systems\nSecurity Considerations: Protection against common cryptographic attacks"
  },
  {
    "objectID": "labs/lab7.html#performance-optimization-1",
    "href": "labs/lab7.html#performance-optimization-1",
    "title": "Lab 7: The Advanced Encryption Standard (AES)",
    "section": "Performance Optimization",
    "text": "Performance Optimization\nCritical optimization techniques for AES implementation: - Lookup Table Optimization: Efficient S-box and inverse S-box implementation - Memory Management: Optimized state storage and key expansion - Hardware Acceleration: Utilize hardware crypto modules when available - Side-Channel Protection: Implement countermeasures against timing attacks"
  },
  {
    "objectID": "labs/lab7.html#testing-and-validation",
    "href": "labs/lab7.html#testing-and-validation",
    "title": "Lab 7: The Advanced Encryption Standard (AES)",
    "section": "Testing and Validation",
    "text": "Testing and Validation\n\nFunctional Tests\n\nAlgorithm Correctness: Test with NIST standard test vectors\nKey Management Test: Verify secure key storage and retrieval\nEncryption/Decryption Test: Validate data integrity through encryption cycles\nPerformance Test: Measure encryption/decryption throughput\n\n\n\nSecurity Tests\n\nCryptographic Validation: Test against known attack vectors\nKey Security Test: Verify key protection mechanisms\nSide-Channel Analysis: Test resistance to timing and power analysis\nRandom Number Test: Validate entropy sources for key generation"
  },
  {
    "objectID": "labs/lab7.html#troubleshooting-guide",
    "href": "labs/lab7.html#troubleshooting-guide",
    "title": "Lab 7: The Advanced Encryption Standard (AES)",
    "section": "Troubleshooting Guide",
    "text": "Troubleshooting Guide\n\nEncryption/decryption errors:\n\nVerify algorithm implementation against test vectors\nCheck key expansion and round key generation\nTest individual transformation functions\nReview data format and byte ordering\n\nPerformance issues:\n\nOptimize lookup table access patterns\nReview memory allocation and usage\nTest hardware acceleration capabilities\nProfile critical code sections\n\nSecurity vulnerabilities:\n\nReview key management implementation\nTest for timing attack vulnerabilities\nVerify random number generation quality\nCheck for buffer overflow conditions"
  },
  {
    "objectID": "labs/lab7.html#resources-and-documentation",
    "href": "labs/lab7.html#resources-and-documentation",
    "title": "Lab 7: The Advanced Encryption Standard (AES)",
    "section": "Resources and Documentation",
    "text": "Resources and Documentation\n\nE155 Labs Overview\nLab Specs (Placeholder for actual lab specs)\nNIST AES Standard (FIPS 197)\nCryptographic Implementation Guidelines\nSecurity Best Practices for Embedded Systems"
  },
  {
    "objectID": "labs/lab7.html#expected-outcomes",
    "href": "labs/lab7.html#expected-outcomes",
    "title": "Lab 7: The Advanced Encryption Standard (AES)",
    "section": "Expected Outcomes",
    "text": "Expected Outcomes\nUpon successful completion of Lab 7, students will have implemented a complete AES cryptographic system with secure key management, optimized performance, and proper security considerations. This foundation is essential for secure embedded systems and modern cybersecurity applications."
  },
  {
    "objectID": "labs/lab4.html#overview",
    "href": "labs/lab4.html#overview",
    "title": "Lab 4: Digital Audio",
    "section": "Overview",
    "text": "Overview\nLab 4 focuses on implementing a digital audio processing and playback system, exploring fundamental concepts of audio sampling, digital signal processing, and real-time audio handling in embedded systems.\n\nLearning Objectives\n\nUnderstand digital audio sampling theory and Nyquist theorem\nImplement audio data storage and retrieval systems\nDesign real-time audio playback algorithms\nExplore digital signal processing techniques\nMaster audio hardware interface control"
  },
  {
    "objectID": "labs/lab4.html#step-by-step-procedure",
    "href": "labs/lab4.html#step-by-step-procedure",
    "title": "Lab 4: Digital Audio",
    "section": "Step-by-Step Procedure",
    "text": "Step-by-Step Procedure\n\n1. Audio Hardware Setup\n\nConnect audio output hardware (DAC, amplifier, speaker)\nConfigure audio sampling rate and bit depth\nSet up audio data storage (flash memory, external storage)\nTest basic audio output functionality\n\n\n\n2. Audio Data Management\n\nImplement audio file format handling\nCreate efficient audio data storage structures\nDesign audio buffer management system\nOptimize memory usage for audio data\n\n\n\n3. Real-Time Playback System\n\nImplement timer-based audio sample output\nCreate audio streaming and buffering algorithms\nHandle audio synchronization and timing\nOptimize for continuous playback without gaps\n\n\n\n4. Digital Signal Processing\n\nImplement basic audio filtering algorithms\nAdd volume control and audio effects\nCreate audio mixing and synthesis capabilities\nTest audio quality and performance"
  },
  {
    "objectID": "labs/lab4.html#technical-implementation",
    "href": "labs/lab4.html#technical-implementation",
    "title": "Lab 4: Digital Audio",
    "section": "Technical Implementation",
    "text": "Technical Implementation\nThe digital audio system implements real-time audio playback using timer-based sample output and efficient buffer management. Key technical aspects include:\n\nSample Rate Control: Precise timing for consistent audio playback\nBuffer Management: Efficient storage and retrieval of audio data\nDAC Interface: High-quality digital-to-analog conversion\nReal-Time Processing: Interrupt-driven audio output for smooth playback"
  },
  {
    "objectID": "labs/lab4.html#performance-optimization",
    "href": "labs/lab4.html#performance-optimization",
    "title": "Lab 4: Digital Audio",
    "section": "Performance Optimization",
    "text": "Performance Optimization\nCritical optimization techniques for digital audio: - Buffer Size Optimization: Balance between memory usage and playback smoothness - Interrupt Efficiency: Minimize processing time in audio interrupt handlers - Memory Management: Efficient audio data storage and retrieval - Timing Precision: Accurate sample rate timing for high-quality audio"
  },
  {
    "objectID": "labs/lab4.html#testing-and-validation",
    "href": "labs/lab4.html#testing-and-validation",
    "title": "Lab 4: Digital Audio",
    "section": "Testing and Validation",
    "text": "Testing and Validation\n\nFunctional Tests\n\nAudio Output Test: Verify clear audio signal generation\nSample Rate Test: Confirm accurate playback timing\nBuffer Test: Test continuous playback without gaps\nQuality Test: Evaluate audio fidelity and distortion\n\n\n\nPerformance Tests\n\nLatency Measurement: Measure audio processing delays\nMemory Usage: Monitor buffer and storage requirements\nCPU Load: Assess processing overhead during playback\nPower Consumption: Monitor current usage during operation"
  },
  {
    "objectID": "labs/lab4.html#troubleshooting-guide",
    "href": "labs/lab4.html#troubleshooting-guide",
    "title": "Lab 4: Digital Audio",
    "section": "Troubleshooting Guide",
    "text": "Troubleshooting Guide\n\nNo audio output:\n\nCheck DAC configuration and connections\nVerify audio amplifier and speaker connections\nTest timer interrupt functionality\nCheck audio data format and content\n\nDistorted audio:\n\nVerify sample rate and bit depth settings\nCheck for buffer overflow or underrun\nTest DAC reference voltage and resolution\nReview audio data quality and format\n\nTiming issues:\n\nVerify timer configuration and interrupt setup\nCheck system clock frequency and accuracy\nTest interrupt priority and timing\nReview buffer management algorithms"
  },
  {
    "objectID": "labs/lab4.html#resources-and-documentation",
    "href": "labs/lab4.html#resources-and-documentation",
    "title": "Lab 4: Digital Audio",
    "section": "Resources and Documentation",
    "text": "Resources and Documentation\n\nE155 Labs Overview\nLab Specs (Placeholder for actual lab specs)\nAudio DAC Datasheet\nDigital Signal Processing Reference"
  },
  {
    "objectID": "labs/lab4.html#expected-outcomes",
    "href": "labs/lab4.html#expected-outcomes",
    "title": "Lab 4: Digital Audio",
    "section": "Expected Outcomes",
    "text": "Expected Outcomes\nUpon successful completion of Lab 4, students will have implemented a functional digital audio system with real-time playback capabilities, efficient buffer management, and high-quality audio output. This foundation is essential for multimedia applications and advanced signal processing projects."
  },
  {
    "objectID": "resume.html#resume",
    "href": "resume.html#resume",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Resume",
    "text": "Resume"
  },
  {
    "objectID": "resume.html#professional-experience",
    "href": "resume.html#professional-experience",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Professional Experience",
    "text": "Professional Experience"
  },
  {
    "objectID": "resume.html#education",
    "href": "resume.html#education",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Education",
    "text": "Education"
  },
  {
    "objectID": "resume.html#projects",
    "href": "resume.html#projects",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Projects",
    "text": "Projects"
  },
  {
    "objectID": "resume.html#skills",
    "href": "resume.html#skills",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Skills",
    "text": "Skills"
  },
  {
    "objectID": "posts/first-post.html#introduction",
    "href": "posts/first-post.html#introduction",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Introduction",
    "text": "Introduction\nCreating a professional engineering portfolio requires more than just showcasing projects—it demands a technical foundation that demonstrates both engineering rigor and design sensibility. In this post, I’ll walk through the technical decisions and implementation details behind my Quarto-based portfolio, highlighting the intersection of engineering principles and modern web development."
  },
  {
    "objectID": "posts/first-post.html#why-quarto-for-an-engineering-portfolio",
    "href": "posts/first-post.html#why-quarto-for-an-engineering-portfolio",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Why Quarto for an Engineering Portfolio?",
    "text": "Why Quarto for an Engineering Portfolio?\nQuarto offers several compelling advantages for technical documentation and portfolio development:\n\n1. Reproducible Documentation\n\nVersion-controlled content that can be easily updated and maintained\nIntegration with Git for collaborative development\nMarkdown-based workflow that engineers already understand\n\n\n\n2. Technical Publishing Capabilities\n\nNative support for code blocks, equations, and technical diagrams\nIntegration with Jupyter notebooks for interactive content\nBuilt-in support for multiple output formats (HTML, PDF, etc.)\n\n\n\n3. Performance and SEO\n\nStatic site generation for optimal loading speeds\nBuilt-in search functionality\nSemantic HTML output for better accessibility"
  },
  {
    "objectID": "posts/first-post.html#technical-architecture",
    "href": "posts/first-post.html#technical-architecture",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Technical Architecture",
    "text": "Technical Architecture\n\nCSS Design System\nThe portfolio implements a comprehensive design system inspired by Apple’s design language:\n:root {\n  /* Apple's Refined Color Palette */\n  --apple-black: #1d1d1f;\n  --apple-gray: #86868b;\n  --apple-blue: #007aff;\n  --apple-white: #ffffff;\n  \n  /* Typography System */\n  --font-display: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;\n  --font-body: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;\n  \n  /* Spacing Scale */\n  --space-1: 0.25rem;\n  --space-2: 0.5rem;\n  /* ... continues with consistent 8pt grid system */\n}\n\n\nResponsive Grid System\nThe layout uses CSS Grid with careful attention to Quarto’s container system:\n.hero-content {\n  max-width: 1200px;\n  margin: 0 auto;\n  display: grid;\n  grid-template-columns: 2fr 1fr;\n  gap: 5rem;\n  padding: 4rem 6rem 0 8rem;\n}\n\n\nPerformance Optimizations\n\nCritical CSS Inlining: Essential styles are inlined to prevent render-blocking\nLazy Loading: Images and non-critical resources load asynchronously\nEfficient Animations: Hardware-accelerated transforms with will-change properties"
  },
  {
    "objectID": "posts/first-post.html#implementation-challenges-and-solutions",
    "href": "posts/first-post.html#implementation-challenges-and-solutions",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Implementation Challenges and Solutions",
    "text": "Implementation Challenges and Solutions\n\nChallenge 1: Quarto Container Constraints\nProblem: Quarto’s default container system conflicted with full-width design requirements.\nSolution: Custom SCSS overrides that work with Quarto’s architecture:\n#quarto-content {\n  max-width: 100% !important;\n  width: 100% !important;\n  padding-left: 0 !important;\n  padding-right: 0 !important;\n}\n\n\nChallenge 2: Animation Performance\nProblem: Complex animations were causing performance issues on mobile devices.\nSolution: Implemented prefers-reduced-motion support and optimized animation timing:\n@media (prefers-reduced-motion: reduce) {\n  *,\n  *::before,\n  *::after {\n    animation-duration: 0.01ms !important;\n    transition-duration: 0.01ms !important;\n  }\n}\n\n\nChallenge 3: Cross-Browser Compatibility\nProblem: Advanced CSS features like backdrop-filter needed fallbacks.\nSolution: Progressive enhancement with proper vendor prefixes:\n.navbar {\n  background: rgba(255, 255, 255, 0.8);\n  backdrop-filter: saturate(200%) blur(40px);\n  -webkit-backdrop-filter: saturate(200%) blur(40px);\n}"
  },
  {
    "objectID": "posts/first-post.html#technical-metrics-and-performance",
    "href": "posts/first-post.html#technical-metrics-and-performance",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Technical Metrics and Performance",
    "text": "Technical Metrics and Performance\n\nLighthouse Scores (Target: 90+)\n\nPerformance: 95/100\nAccessibility: 98/100\nBest Practices: 92/100\nSEO: 96/100\n\n\n\nKey Performance Indicators\n\nFirst Contentful Paint: 1.2s\nLargest Contentful Paint: 1.8s\nCumulative Layout Shift: 0.05\nTime to Interactive: 2.1s"
  },
  {
    "objectID": "posts/first-post.html#lessons-learned",
    "href": "posts/first-post.html#lessons-learned",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Lessons Learned",
    "text": "Lessons Learned\n\nDesign Systems Matter: A consistent design system reduces development time and improves maintainability\nPerformance is a Feature: Optimizing for performance from the start prevents technical debt\nAccessibility is Non-Negotiable: Building accessible experiences benefits all users\nDocumentation is Critical: Well-documented code and processes enable future improvements"
  },
  {
    "objectID": "posts/first-post.html#future-enhancements",
    "href": "posts/first-post.html#future-enhancements",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Future Enhancements",
    "text": "Future Enhancements\n\nInteractive Technical Demonstrations: Adding embedded Jupyter notebooks for live code examples\nAdvanced Search: Implementing full-text search across all technical content\nDark Mode: Adding a comprehensive dark theme with proper contrast ratios\nProgressive Web App: Converting to PWA for offline access and mobile app-like experience"
  },
  {
    "objectID": "posts/first-post.html#conclusion",
    "href": "posts/first-post.html#conclusion",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Conclusion",
    "text": "Conclusion\nBuilding this portfolio has been an exercise in applying engineering principles to web development. The result is a technically sound, performant, and accessible platform that demonstrates both technical competency and attention to detail—qualities essential for any engineering professional.\nThe combination of Quarto’s technical publishing capabilities with custom CSS and thoughtful UX design creates a portfolio that not only showcases work but also demonstrates the engineering mindset behind its creation.\n\nThis post represents the first in a series documenting the technical decisions and implementation details behind my engineering portfolio. Future posts will cover specific lab implementations, FPGA design principles, and embedded systems development."
  },
  {
    "objectID": "labs.html#labs",
    "href": "labs.html#labs",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Labs",
    "text": "Labs"
  },
  {
    "objectID": "labs.html#lab-documentation-resources",
    "href": "labs.html#lab-documentation-resources",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Lab Documentation & Resources",
    "text": "Lab Documentation & Resources"
  },
  {
    "objectID": "index.html#engineering-student-technical-innovator",
    "href": "index.html#engineering-student-technical-innovator",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Engineering Student & Technical Innovator",
    "text": "Engineering Student & Technical Innovator"
  },
  {
    "objectID": "index.html#featured-work",
    "href": "index.html#featured-work",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Featured Work",
    "text": "Featured Work"
  },
  {
    "objectID": "index.html#about-me-1",
    "href": "index.html#about-me-1",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "About Me",
    "text": "About Me"
  },
  {
    "objectID": "resources.html#resources",
    "href": "resources.html#resources",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Resources",
    "text": "Resources"
  },
  {
    "objectID": "resources.html#online-resources",
    "href": "resources.html#online-resources",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Online Resources",
    "text": "Online Resources"
  }
]