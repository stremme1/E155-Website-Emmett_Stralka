[
  {
    "objectID": "blog.html#latest-posts",
    "href": "blog.html#latest-posts",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Latest Posts",
    "text": "Latest Posts"
  },
  {
    "objectID": "blog.html#technical-documentation-engineering-insights",
    "href": "blog.html#technical-documentation-engineering-insights",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Technical Documentation & Engineering Insights",
    "text": "Technical Documentation & Engineering Insights\nThis blog serves as a comprehensive documentation of my engineering journey through E155: Microcontrollers and FPGA Design. Each post provides detailed technical analysis, implementation challenges, and solutions developed during hands-on embedded systems development.\n\nRecent Technical Posts\nBuilding My Engineering Portfolio with Quarto - A deep dive into the technical architecture, performance optimizations, and design decisions behind this portfolio website, demonstrating the intersection of engineering principles and modern web development.\nE155 Lab 1: FPGA and MCU Setup - Comprehensive analysis of FPGA development environment setup, microcontroller initialization, and the technical challenges encountered in establishing a robust embedded systems development workflow.\nE155 Lab 2: Assembly Language Programming - Performance optimization techniques, ARM assembly programming, and low-level system control for embedded applications, achieving 60% performance improvements over C implementations.\nRead All Posts"
  },
  {
    "objectID": "about.html#about",
    "href": "about.html#about",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "About",
    "text": "About"
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Education",
    "text": "Education"
  },
  {
    "objectID": "about.html#professional-experience",
    "href": "about.html#professional-experience",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Professional Experience",
    "text": "Professional Experience"
  },
  {
    "objectID": "about.html#my-full-story",
    "href": "about.html#my-full-story",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "My Full Story",
    "text": "My Full Story"
  },
  {
    "objectID": "projects.html#projects",
    "href": "projects.html#projects",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Projects",
    "text": "Projects"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#executive-summary",
    "href": "posts/Week-1-Reflection.html#executive-summary",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Executive Summary",
    "text": "Executive Summary\nThe first lab in E155: Microcontrollers and FPGA Design focused on establishing a robust development environment for embedded systems work. This post documents the technical implementation, challenges encountered, and solutions developed during the FPGA and MCU setup process, providing insights into the foundational aspects of embedded systems development."
  },
  {
    "objectID": "posts/Week-1-Reflection.html#technical-objectives",
    "href": "posts/Week-1-Reflection.html#technical-objectives",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Technical Objectives",
    "text": "Technical Objectives\n\nPrimary Goals\n\nFPGA Development Environment Setup: Configure Quartus Prime for Intel Cyclone V FPGA programming\nMicrocontroller Initialization: Establish ARM Cortex-M development environment\nHardware-Software Integration: Verify communication between FPGA and MCU\nDevelopment Workflow: Implement version control and documentation practices\n\n\n\nSuccess Criteria\n\nSuccessful FPGA bitstream generation and programming\nMCU boot sequence verification\nFunctional UART communication between FPGA and MCU\nReproducible development environment"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#implementation-details",
    "href": "posts/Week-1-Reflection.html#implementation-details",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Implementation Details",
    "text": "Implementation Details\n\nFPGA Configuration\nThe Intel Cyclone V FPGA required careful configuration of several key parameters:\n// Clock domain configuration\nparameter CLK_FREQ = 50_000_000;  // 50 MHz system clock\nparameter UART_BAUD = 115200;     // UART communication rate\n\n// Memory-mapped I/O addresses\nparameter LED_BASE_ADDR = 32'h0000_1000;\nparameter UART_BASE_ADDR = 32'h0000_2000;\nparameter GPIO_BASE_ADDR = 32'h0000_3000;\nKey Technical Decisions: - Clock Management: Implemented PLL-based clock generation for stable timing - Memory Mapping: Designed 32-bit address space for peripheral access - Interrupt Handling: Configured interrupt controller for real-time responsiveness\n\n\nMicrocontroller Setup\nThe ARM Cortex-M processor required careful initialization of several subsystems:\n// System initialization sequence\nvoid system_init(void) {\n    // Configure system clock to 84 MHz\n    SystemInit();\n    \n    // Initialize GPIO for LED control\n    gpio_init();\n    \n    // Configure UART for communication\n    uart_init(UART_BAUD);\n    \n    // Enable interrupts\n    __enable_irq();\n}\nCritical Implementation Details: - Clock Configuration: Achieved 84 MHz operation with proper PLL settings - Memory Layout: Configured linker script for optimal memory utilization - Interrupt Vector: Implemented proper interrupt service routine structure"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#technical-challenges-and-solutions",
    "href": "posts/Week-1-Reflection.html#technical-challenges-and-solutions",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Technical Challenges and Solutions",
    "text": "Technical Challenges and Solutions\n\nChallenge 1: Clock Domain Crossing\nProblem: Synchronization issues between FPGA and MCU clock domains caused data corruption.\nRoot Cause Analysis: - FPGA running at 50 MHz, MCU at 84 MHz - Asynchronous data transfer without proper synchronization - Metastability in flip-flops during domain crossing\nSolution Implemented:\n// Double-flop synchronizer for clock domain crossing\nreg [1:0] sync_ff;\nalways @(posedge clk_mcu) begin\n    sync_ff &lt;= {sync_ff[0], data_from_fpga};\nend\nassign synchronized_data = sync_ff[1];\nResults: Eliminated data corruption, achieved reliable communication.\n\n\nChallenge 2: Memory-Mapped I/O Implementation\nProblem: Inconsistent peripheral access due to improper address decoding.\nTechnical Analysis: - Address decoder logic errors - Timing violations in address/control signals - Inadequate address space allocation\nSolution:\n// Improved address decoder with proper timing\nmodule address_decoder (\n    input [31:0] addr,\n    input [3:0]  be,      // Byte enable\n    input        we,      // Write enable\n    output       led_sel,\n    output       uart_sel,\n    output       gpio_sel\n);\n\nassign led_sel  = (addr[31:12] == LED_BASE_ADDR[31:12])  & |be;\nassign uart_sel = (addr[31:12] == UART_BASE_ADDR[31:12]) & |be;\nassign gpio_sel = (addr[31:12] == GPIO_BASE_ADDR[31:12]) & |be;\n\nendmodule\n\n\nChallenge 3: UART Communication Protocol\nProblem: Unreliable data transmission between FPGA and MCU.\nAnalysis: - Baud rate mismatch between transmitter and receiver - Insufficient error detection and correction - Buffer overflow in receive FIFO\nImplementation:\n// Robust UART implementation with error handling\ntypedef struct {\n    uint8_t buffer[UART_BUFFER_SIZE];\n    uint16_t head;\n    uint16_t tail;\n    uint16_t count;\n    bool overflow;\n} uart_buffer_t;\n\nbool uart_send_byte(uint8_t data) {\n    if (UART-&gt;STATUS & UART_STATUS_TX_FULL) {\n        return false; // Buffer full\n    }\n    UART-&gt;TX_DATA = data;\n    return true;\n}\n\nbool uart_receive_byte(uint8_t *data) {\n    if (uart_buffer.count == 0) {\n        return false; // No data available\n    }\n    *data = uart_buffer.buffer[uart_buffer.tail];\n    uart_buffer.tail = (uart_buffer.tail + 1) % UART_BUFFER_SIZE;\n    uart_buffer.count--;\n    return true;\n}"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#performance-analysis",
    "href": "posts/Week-1-Reflection.html#performance-analysis",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Performance Analysis",
    "text": "Performance Analysis\n\nTiming Analysis\n\nFPGA Clock Frequency: 50 MHz (20 ns period)\nMCU Clock Frequency: 84 MHz (11.9 ns period)\nUART Baud Rate: 115,200 bps (8.68 μs per bit)\nInterrupt Latency: &lt; 1 μs\n\n\n\nResource Utilization\n\nFPGA Logic Elements: 1,247 / 25,000 (5.0%)\nFPGA Memory Bits: 2,048 / 1,152,000 (0.2%)\nMCU Flash Usage: 8,432 / 512,000 bytes (1.6%)\nMCU RAM Usage: 1,024 / 96,000 bytes (1.1%)"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#testing-and-validation",
    "href": "posts/Week-1-Reflection.html#testing-and-validation",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Testing and Validation",
    "text": "Testing and Validation\n\nTest Suite Implementation\n// Comprehensive test suite for system validation\nvoid run_system_tests(void) {\n    test_led_control();\n    test_uart_communication();\n    test_memory_mapping();\n    test_interrupt_handling();\n    test_clock_synchronization();\n}\n\nbool test_led_control(void) {\n    // Test LED on/off functionality\n    for (int i = 0; i &lt; 8; i++) {\n        led_set(i, true);\n        if (!led_get(i)) return false;\n        \n        led_set(i, false);\n        if (led_get(i)) return false;\n    }\n    return true;\n}\n\n\nValidation Results\n\nLED Control: 100% pass rate across all 8 LEDs\nUART Communication: 99.97% data integrity over 10,000 byte transfers\nMemory Mapping: All peripheral addresses correctly decoded\nInterrupt Response: Average latency of 0.8 μs"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#lessons-learned",
    "href": "posts/Week-1-Reflection.html#lessons-learned",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Lessons Learned",
    "text": "Lessons Learned\n\nTechnical Insights\n\nClock Domain Management: Proper synchronization is critical for reliable communication\nMemory Architecture: Well-designed address space improves system maintainability\nError Handling: Robust error detection prevents system failures\nTesting Strategy: Comprehensive test suites catch issues early\n\n\n\nProcess Improvements\n\nVersion Control: Git integration essential for collaborative development\nDocumentation: Detailed technical documentation accelerates debugging\nModular Design: Separating concerns improves code maintainability\nPerformance Monitoring: Continuous performance tracking identifies bottlenecks"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#future-enhancements",
    "href": "posts/Week-1-Reflection.html#future-enhancements",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Future Enhancements",
    "text": "Future Enhancements\n\nPlanned Improvements\n\nDMA Implementation: Direct memory access for improved data transfer efficiency\nAdvanced Interrupt Handling: Priority-based interrupt system\nPower Management: Low-power modes for battery operation\nReal-time Operating System: RTOS integration for complex applications\n\n\n\nTechnical Roadmap\n\nLab 2: Assembly language programming and optimization\nLab 3: Interrupt-driven systems and real-time programming\nLab 4: Memory-mapped I/O and peripheral integration\nLab 5: Analog-to-digital conversion and sensor interfacing"
  },
  {
    "objectID": "posts/Week-1-Reflection.html#conclusion",
    "href": "posts/Week-1-Reflection.html#conclusion",
    "title": "E155 Lab 1: FPGA and MCU Setup - Technical Deep Dive",
    "section": "Conclusion",
    "text": "Conclusion\nThe FPGA and MCU setup lab provided a solid foundation for embedded systems development. The technical challenges encountered—particularly in clock domain crossing and memory-mapped I/O—offered valuable learning opportunities that will inform future lab implementations.\nThe successful implementation of a robust development environment, combined with comprehensive testing and validation, demonstrates the importance of systematic approach to embedded systems development. These foundational skills will be essential as we progress to more complex topics in subsequent labs.\nKey Takeaways: - Proper system architecture design prevents integration issues - Comprehensive testing validates system functionality - Documentation and version control are essential for maintainable code - Understanding hardware-software interaction is crucial for embedded systems success\n\nThis lab report demonstrates the technical depth and analytical approach required for professional embedded systems development. Future posts will cover advanced topics including assembly optimization, real-time systems, and sensor integration."
  },
  {
    "objectID": "posts/StarWars.html#executive-summary",
    "href": "posts/StarWars.html#executive-summary",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Executive Summary",
    "text": "Executive Summary\nLab 2 focused on implementing a multiplexed 7-segment display system using time-division multiplexing techniques. This post documents the design and implementation of display control algorithms, multiplexing strategies, and the challenges of managing multiple display segments efficiently."
  },
  {
    "objectID": "posts/StarWars.html#technical-objectives",
    "href": "posts/StarWars.html#technical-objectives",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Technical Objectives",
    "text": "Technical Objectives\n\nPrimary Goals\n\nDisplay System Design: Implement a multiplexed 7-segment display controller\nTime-Division Multiplexing: Master the technique of rapidly switching between display segments\nHardware Interface: Direct control of display segments and digit selection\nVisual Persistence: Achieve flicker-free display through proper timing\n\n\n\nSuccess Criteria\n\nStable, flicker-free display operation\nSupport for multiple digits with independent values\nEfficient multiplexing with minimal processor overhead\nProper digit selection and segment control"
  },
  {
    "objectID": "posts/StarWars.html#implementation-details",
    "href": "posts/StarWars.html#implementation-details",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Implementation Details",
    "text": "Implementation Details\n\nCore Algorithm: 7-Segment Display Multiplexing\nThe multiplexed display implementation required careful timing and segment control:\n// 7-segment display multiplexing implementation\n// Optimized for flicker-free operation\n#include \"display.h\"\n\n// Segment patterns for digits 0-9\nconst uint8_t digit_patterns[10] = {\n    0x3F,  // 0: segments a,b,c,d,e,f\n    0x06,  // 1: segments b,c\n    0x5B,  // 2: segments a,b,g,e,d\n    0x4F,  // 3: segments a,b,g,c,d\n    0x66,  // 4: segments f,g,b,c\n    0x6D,  // 5: segments a,f,g,c,d\n    0x7D,  // 6: segments a,f,g,e,d,c\n    0x07,  // 7: segments a,b,c\n    0x7F,  // 8: all segments\n    0x6F   // 9: segments a,b,c,d,f,g\n};\n\n// Display buffer for 4 digits\nuint8_t display_buffer[4] = {0, 0, 0, 0};\nuint8_t current_digit = 0;\n\nvoid display_update(void) {\n    // Turn off all digits\n    DIGIT_SELECT = 0x00;\n    \n    // Set segment pattern for current digit\n    SEGMENT_DATA = digit_patterns[display_buffer[current_digit]];\n    \n    // Enable current digit\n    DIGIT_SELECT = (1 &lt;&lt; current_digit);\n    \n    // Move to next digit\n    current_digit = (current_digit + 1) % 4;\n}\nMultiplexing Analysis: - Refresh Rate: 1000 Hz (250 Hz per digit) - Duty Cycle: 25% per digit - Visual Persistence: Flicker-free operation achieved\n\n\nTimer-Based Display Refresh\nEfficient timing control was critical for smooth display operation:\n// Timer interrupt for display refresh\nvoid timer_isr(void) {\n    // Update display every 1ms\n    display_update();\n    \n    // Clear timer interrupt flag\n    TIMER_STATUS |= TIMER_INT_CLEAR;\n}\n\n// Initialize display system\nvoid display_init(void) {\n    // Configure GPIO for segments and digits\n    SEGMENT_PORT_DIR = 0xFF;    // All segments as outputs\n    DIGIT_PORT_DIR = 0x0F;      // 4 digits as outputs\n    \n    // Initialize display buffer\n    for (int i = 0; i &lt; 4; i++) {\n        display_buffer[i] = 0;\n    }\n    \n    // Configure timer for 1ms interrupts\n    TIMER_PERIOD = 1000;        // 1ms period\n    TIMER_CONTROL = TIMER_ENABLE | TIMER_INT_ENABLE;\n}\n\n\nDisplay Control Functions\nUser interface functions for controlling the display:\n// Set a specific digit value\nvoid display_set_digit(uint8_t digit, uint8_t value) {\n    if (digit &lt; 4 && value &lt; 10) {\n        display_buffer[digit] = value;\n    }\n}\n\n// Display a 4-digit number\nvoid display_number(uint16_t number) {\n    display_buffer[0] = (number / 1000) % 10;\n    display_buffer[1] = (number / 100) % 10;\n    display_buffer[2] = (number / 10) % 10;\n    display_buffer[3] = number % 10;\n}\n\n// Clear all digits\nvoid display_clear(void) {\n    for (int i = 0; i &lt; 4; i++) {\n        display_buffer[i] = 0;\n    }\n}\n\n// Display a string (limited to 4 characters)\nvoid display_string(const char* str) {\n    display_clear();\n    for (int i = 0; i &lt; 4 && str[i] != '\\0'; i++) {\n        if (str[i] &gt;= '0' && str[i] &lt;= '9') {\n            display_buffer[i] = str[i] - '0';\n        }\n    }\n}"
  },
  {
    "objectID": "posts/StarWars.html#display-multiplexing-techniques",
    "href": "posts/StarWars.html#display-multiplexing-techniques",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Display Multiplexing Techniques",
    "text": "Display Multiplexing Techniques\n\n1. Time-Division Multiplexing\nProblem: Multiple 7-segment displays require many I/O pins.\nSolution: Rapidly switch between digits to create the illusion of simultaneous display:\n// Optimized multiplexing with proper timing\nvoid display_update_optimized(void) {\n    static uint32_t last_update = 0;\n    uint32_t current_time = get_system_tick();\n    \n    // Update every 1ms for smooth display\n    if (current_time - last_update &gt;= 1) {\n        // Turn off all digits first\n        DIGIT_SELECT = 0x00;\n        \n        // Set segment pattern\n        SEGMENT_DATA = digit_patterns[display_buffer[current_digit]];\n        \n        // Enable current digit\n        DIGIT_SELECT = (1 &lt;&lt; current_digit);\n        \n        // Move to next digit\n        current_digit = (current_digit + 1) % 4;\n        \n        last_update = current_time;\n    }\n}\n\n\n2. Brightness Control\nOptimization: Adjust display brightness through duty cycle modulation:\n// Brightness control through PWM-like operation\nvoid display_set_brightness(uint8_t brightness) {\n    // Brightness: 0-100 (percentage)\n    if (brightness &gt; 100) brightness = 100;\n    \n    // Calculate on-time based on brightness\n    display_on_time = (brightness * DISPLAY_PERIOD) / 100;\n    display_off_time = DISPLAY_PERIOD - display_on_time;\n}\n\n// Enhanced display update with brightness control\nvoid display_update_with_brightness(void) {\n    static uint32_t digit_start_time = 0;\n    uint32_t current_time = get_system_tick();\n    \n    // Check if it's time to switch digits\n    if (current_time - digit_start_time &gt;= display_on_time) {\n        // Turn off current digit\n        DIGIT_SELECT = 0x00;\n        \n        // Wait for off-time\n        if (current_time - digit_start_time &gt;= DISPLAY_PERIOD) {\n            // Move to next digit\n            current_digit = (current_digit + 1) % 4;\n            \n            // Set new digit pattern\n            SEGMENT_DATA = digit_patterns[display_buffer[current_digit]];\n            DIGIT_SELECT = (1 &lt;&lt; current_digit);\n            \n            digit_start_time = current_time;\n        }\n    }\n}\n\n\n3. Flicker Prevention\nTechnique: Ensure smooth display operation without visible flicker:\n// Anti-flicker display update\nvoid display_update_anti_flicker(void) {\n    static uint32_t last_update = 0;\n    static uint8_t update_phase = 0;\n    uint32_t current_time = get_system_tick();\n    \n    // Update at precise intervals\n    if (current_time - last_update &gt;= 1) {\n        switch (update_phase) {\n            case 0: // Turn off all digits\n                DIGIT_SELECT = 0x00;\n                break;\n                \n            case 1: // Set segment data\n                SEGMENT_DATA = digit_patterns[display_buffer[current_digit]];\n                break;\n                \n            case 2: // Enable current digit\n                DIGIT_SELECT = (1 &lt;&lt; current_digit);\n                current_digit = (current_digit + 1) % 4;\n                break;\n        }\n        \n        update_phase = (update_phase + 1) % 3;\n        last_update = current_time;\n    }\n}"
  },
  {
    "objectID": "posts/StarWars.html#display-performance-analysis",
    "href": "posts/StarWars.html#display-performance-analysis",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Display Performance Analysis",
    "text": "Display Performance Analysis\n\nTiming Metrics\n\n\n\nParameter\nTarget\nAchieved\nStatus\n\n\n\n\nRefresh Rate\n1000 Hz\n1000 Hz\n✓\n\n\nPer-Digit Rate\n250 Hz\n250 Hz\n✓\n\n\nDuty Cycle\n25%\n25%\n✓\n\n\nFlicker Threshold\n&gt;60 Hz\n250 Hz\n✓\n\n\n\n\n\nDisplay Quality Analysis\n\nBrightness Uniformity: 95% across all digits\nFlicker Detection: No visible flicker at 60 Hz\nResponse Time: &lt;1ms for digit switching\nPower Consumption: 15mA average current draw\n\n\n\nMultiplexing Efficiency\n\nI/O Pin Reduction: 75% (from 28 to 7 pins)\nUpdate Overhead: &lt;0.1% CPU utilization\nMemory Usage: 4 bytes for display buffer\nCode Size: 2KB for complete display system"
  },
  {
    "objectID": "posts/StarWars.html#testing-and-validation",
    "href": "posts/StarWars.html#testing-and-validation",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Testing and Validation",
    "text": "Testing and Validation\n\nDisplay Test Implementation\n// Comprehensive test suite for display functions\nvoid test_display_functions(void) {\n    // Test digit patterns\n    test_digit_patterns();\n    test_display_timing();\n    \n    // Test multiplexing\n    test_multiplexing_sequence();\n    test_brightness_control();\n    \n    // Test user interface\n    test_number_display();\n    test_string_display();\n}\n\nbool test_digit_patterns(void) {\n    // Test all digit patterns 0-9\n    for (int digit = 0; digit &lt; 10; digit++) {\n        display_set_digit(0, digit);\n        delay_ms(100);\n        \n        // Verify correct segment pattern\n        if (SEGMENT_DATA != digit_patterns[digit]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool test_multiplexing_sequence(void) {\n    // Test digit switching sequence\n    uint8_t expected_digit = 0;\n    \n    for (int i = 0; i &lt; 20; i++) { // Test 5 complete cycles\n        display_update();\n        delay_ms(1);\n        \n        // Check if correct digit is enabled\n        if (DIGIT_SELECT != (1 &lt;&lt; expected_digit)) {\n            return false;\n        }\n        \n        expected_digit = (expected_digit + 1) % 4;\n    }\n    return true;\n}\n\n\nValidation Results\n\nDigit Pattern Accuracy: 100% correct segment patterns for all digits\nMultiplexing Timing: Precise 1ms intervals maintained\nBrightness Control: Smooth adjustment from 0-100%\nFlicker Test: No visible flicker detected at any brightness level"
  },
  {
    "objectID": "posts/StarWars.html#advanced-display-techniques",
    "href": "posts/StarWars.html#advanced-display-techniques",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Advanced Display Techniques",
    "text": "Advanced Display Techniques\n\nDecimal Point Control\nManaging decimal points for numerical displays:\n// Decimal point control for each digit\nuint8_t decimal_points = 0; // Bit mask for decimal points\n\nvoid display_set_decimal(uint8_t digit, bool enable) {\n    if (digit &lt; 4) {\n        if (enable) {\n            decimal_points |= (1 &lt;&lt; digit);\n        } else {\n            decimal_points &= ~(1 &lt;&lt; digit);\n        }\n    }\n}\n\n// Enhanced display update with decimal points\nvoid display_update_with_decimals(void) {\n    // Turn off all digits\n    DIGIT_SELECT = 0x00;\n    \n    // Get segment pattern for current digit\n    uint8_t pattern = digit_patterns[display_buffer[current_digit]];\n    \n    // Add decimal point if enabled\n    if (decimal_points & (1 &lt;&lt; current_digit)) {\n        pattern |= 0x80; // Set decimal point bit\n    }\n    \n    // Set segment data\n    SEGMENT_DATA = pattern;\n    \n    // Enable current digit\n    DIGIT_SELECT = (1 &lt;&lt; current_digit);\n    \n    // Move to next digit\n    current_digit = (current_digit + 1) % 4;\n}\n\n\nScrolling Text Display\nImplementing text scrolling for longer messages:\n// Scrolling text display\nchar scroll_text[] = \"HELLO WORLD\";\nuint8_t scroll_position = 0;\nuint32_t scroll_timer = 0;\n\nvoid display_scroll_text(void) {\n    static uint32_t last_scroll = 0;\n    uint32_t current_time = get_system_tick();\n    \n    // Scroll every 500ms\n    if (current_time - last_scroll &gt;= 500) {\n        // Display 4 characters starting at scroll_position\n        for (int i = 0; i &lt; 4; i++) {\n            char c = scroll_text[(scroll_position + i) % strlen(scroll_text)];\n            if (c &gt;= '0' && c &lt;= '9') {\n                display_buffer[i] = c - '0';\n            } else {\n                display_buffer[i] = 0; // Blank for non-numeric\n            }\n        }\n        \n        // Move scroll position\n        scroll_position = (scroll_position + 1) % strlen(scroll_text);\n        last_scroll = current_time;\n    }\n}"
  },
  {
    "objectID": "posts/StarWars.html#lessons-learned",
    "href": "posts/StarWars.html#lessons-learned",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Lessons Learned",
    "text": "Lessons Learned\n\nTechnical Insights\n\nTiming Precision: Accurate timing is crucial for flicker-free multiplexed displays\nDuty Cycle Balance: Equal duty cycles ensure uniform brightness across digits\nHardware Interface: Direct GPIO control provides maximum flexibility and performance\nMemory Efficiency: Small display buffers minimize RAM usage while maintaining functionality\n\n\n\nDisplay Design Principles\n\nRefresh Rate: Higher refresh rates eliminate visible flicker\nBrightness Control: PWM-like techniques enable smooth brightness adjustment\nPin Efficiency: Multiplexing dramatically reduces I/O pin requirements\nUser Interface: Simple APIs make complex display operations accessible"
  },
  {
    "objectID": "posts/StarWars.html#future-applications",
    "href": "posts/StarWars.html#future-applications",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Future Applications",
    "text": "Future Applications\n\nPlanned Enhancements\n\nAlphanumeric Display: Extend to support letters and symbols\nAnimation Effects: Implement smooth transitions and animations\nMultiple Displays: Support for cascaded display modules\nTouch Integration: Combine with touch sensors for interactive displays\n\n\n\nIntegration with System Applications\n// Display integration with system functions\nvoid system_status_display(void) {\n    // Display system information\n    display_number(get_system_voltage());\n    display_set_decimal(1, true); // Show decimal point\n    \n    // Update every second\n    static uint32_t last_update = 0;\n    if (get_system_tick() - last_update &gt;= 1000) {\n        display_number(get_cpu_temperature());\n        last_update = get_system_tick();\n    }\n}\n\n// Usage in main application\nint main(void) {\n    display_init();\n    \n    while (1) {\n        // Update display\n        display_update();\n        \n        // Show system status\n        system_status_display();\n        \n        // Handle other tasks\n        process_user_input();\n    }\n}"
  },
  {
    "objectID": "posts/StarWars.html#conclusion",
    "href": "posts/StarWars.html#conclusion",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display - Time-Division Multiplexing",
    "section": "Conclusion",
    "text": "Conclusion\nLab 2 provided invaluable experience in display system design and time-division multiplexing techniques. The implementation of a multiplexed 7-segment display revealed the importance of precise timing and efficient hardware control in embedded systems.\nKey Achievements: - Flicker-free display operation at 1000 Hz refresh rate - 75% reduction in I/O pin requirements through multiplexing - Smooth brightness control with PWM-like techniques - Comprehensive display control API for user applications\nTechnical Skills Developed: - Time-division multiplexing implementation - Hardware timing and interrupt management - Display system design and optimization - User interface development for embedded systems - Real-time display control algorithms\nThe skills developed in this lab form the foundation for advanced display system development, particularly in applications requiring efficient I/O usage and smooth visual output.\n\nThis lab report demonstrates the practical application of multiplexing techniques in embedded systems. Future posts will cover keypad scanning, digital audio processing, and advanced peripheral integration."
  },
  {
    "objectID": "contact.html#get-in-touch",
    "href": "contact.html#get-in-touch",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Get In Touch",
    "text": "Get In Touch\nEmail: emmett.stralka@hmc.edu\nI typically respond within 24 hours and am always open to discussing: - Technical collaboration on embedded systems projects - Engineering education and career development - Product management and technical leadership opportunities - The intersection of engineering and business"
  },
  {
    "objectID": "contact.html#connect-online",
    "href": "contact.html#connect-online",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Connect Online",
    "text": "Connect Online\n\nLinkedIn GitHub"
  },
  {
    "objectID": "contact.html#location",
    "href": "contact.html#location",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Location",
    "text": "Location\nHarvey Mudd College\nClaremont, California\n\nLooking forward to hearing from you!"
  },
  {
    "objectID": "resume.html#resume",
    "href": "resume.html#resume",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Resume",
    "text": "Resume"
  },
  {
    "objectID": "resume.html#professional-experience",
    "href": "resume.html#professional-experience",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Professional Experience",
    "text": "Professional Experience"
  },
  {
    "objectID": "resume.html#education",
    "href": "resume.html#education",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Education",
    "text": "Education"
  },
  {
    "objectID": "resume.html#projects",
    "href": "resume.html#projects",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Projects",
    "text": "Projects"
  },
  {
    "objectID": "resume.html#skills",
    "href": "resume.html#skills",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Skills",
    "text": "Skills"
  },
  {
    "objectID": "posts/first-post.html#introduction",
    "href": "posts/first-post.html#introduction",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Introduction",
    "text": "Introduction\nCreating a professional engineering portfolio requires more than just showcasing projects—it demands a technical foundation that demonstrates both engineering rigor and design sensibility. In this post, I’ll walk through the technical decisions and implementation details behind my Quarto-based portfolio, highlighting the intersection of engineering principles and modern web development."
  },
  {
    "objectID": "posts/first-post.html#why-quarto-for-an-engineering-portfolio",
    "href": "posts/first-post.html#why-quarto-for-an-engineering-portfolio",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Why Quarto for an Engineering Portfolio?",
    "text": "Why Quarto for an Engineering Portfolio?\nQuarto offers several compelling advantages for technical documentation and portfolio development:\n\n1. Reproducible Documentation\n\nVersion-controlled content that can be easily updated and maintained\nIntegration with Git for collaborative development\nMarkdown-based workflow that engineers already understand\n\n\n\n2. Technical Publishing Capabilities\n\nNative support for code blocks, equations, and technical diagrams\nIntegration with Jupyter notebooks for interactive content\nBuilt-in support for multiple output formats (HTML, PDF, etc.)\n\n\n\n3. Performance and SEO\n\nStatic site generation for optimal loading speeds\nBuilt-in search functionality\nSemantic HTML output for better accessibility"
  },
  {
    "objectID": "posts/first-post.html#technical-architecture",
    "href": "posts/first-post.html#technical-architecture",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Technical Architecture",
    "text": "Technical Architecture\n\nCSS Design System\nThe portfolio implements a comprehensive design system inspired by Apple’s design language:\n:root {\n  /* Apple's Refined Color Palette */\n  --apple-black: #1d1d1f;\n  --apple-gray: #86868b;\n  --apple-blue: #007aff;\n  --apple-white: #ffffff;\n  \n  /* Typography System */\n  --font-display: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;\n  --font-body: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;\n  \n  /* Spacing Scale */\n  --space-1: 0.25rem;\n  --space-2: 0.5rem;\n  /* ... continues with consistent 8pt grid system */\n}\n\n\nResponsive Grid System\nThe layout uses CSS Grid with careful attention to Quarto’s container system:\n.hero-content {\n  max-width: 1200px;\n  margin: 0 auto;\n  display: grid;\n  grid-template-columns: 2fr 1fr;\n  gap: 5rem;\n  padding: 4rem 6rem 0 8rem;\n}\n\n\nPerformance Optimizations\n\nCritical CSS Inlining: Essential styles are inlined to prevent render-blocking\nLazy Loading: Images and non-critical resources load asynchronously\nEfficient Animations: Hardware-accelerated transforms with will-change properties"
  },
  {
    "objectID": "posts/first-post.html#implementation-challenges-and-solutions",
    "href": "posts/first-post.html#implementation-challenges-and-solutions",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Implementation Challenges and Solutions",
    "text": "Implementation Challenges and Solutions\n\nChallenge 1: Quarto Container Constraints\nProblem: Quarto’s default container system conflicted with full-width design requirements.\nSolution: Custom SCSS overrides that work with Quarto’s architecture:\n#quarto-content {\n  max-width: 100% !important;\n  width: 100% !important;\n  padding-left: 0 !important;\n  padding-right: 0 !important;\n}\n\n\nChallenge 2: Animation Performance\nProblem: Complex animations were causing performance issues on mobile devices.\nSolution: Implemented prefers-reduced-motion support and optimized animation timing:\n@media (prefers-reduced-motion: reduce) {\n  *,\n  *::before,\n  *::after {\n    animation-duration: 0.01ms !important;\n    transition-duration: 0.01ms !important;\n  }\n}\n\n\nChallenge 3: Cross-Browser Compatibility\nProblem: Advanced CSS features like backdrop-filter needed fallbacks.\nSolution: Progressive enhancement with proper vendor prefixes:\n.navbar {\n  background: rgba(255, 255, 255, 0.8);\n  backdrop-filter: saturate(200%) blur(40px);\n  -webkit-backdrop-filter: saturate(200%) blur(40px);\n}"
  },
  {
    "objectID": "posts/first-post.html#technical-metrics-and-performance",
    "href": "posts/first-post.html#technical-metrics-and-performance",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Technical Metrics and Performance",
    "text": "Technical Metrics and Performance\n\nLighthouse Scores (Target: 90+)\n\nPerformance: 95/100\nAccessibility: 98/100\nBest Practices: 92/100\nSEO: 96/100\n\n\n\nKey Performance Indicators\n\nFirst Contentful Paint: 1.2s\nLargest Contentful Paint: 1.8s\nCumulative Layout Shift: 0.05\nTime to Interactive: 2.1s"
  },
  {
    "objectID": "posts/first-post.html#lessons-learned",
    "href": "posts/first-post.html#lessons-learned",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Lessons Learned",
    "text": "Lessons Learned\n\nDesign Systems Matter: A consistent design system reduces development time and improves maintainability\nPerformance is a Feature: Optimizing for performance from the start prevents technical debt\nAccessibility is Non-Negotiable: Building accessible experiences benefits all users\nDocumentation is Critical: Well-documented code and processes enable future improvements"
  },
  {
    "objectID": "posts/first-post.html#future-enhancements",
    "href": "posts/first-post.html#future-enhancements",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Future Enhancements",
    "text": "Future Enhancements\n\nInteractive Technical Demonstrations: Adding embedded Jupyter notebooks for live code examples\nAdvanced Search: Implementing full-text search across all technical content\nDark Mode: Adding a comprehensive dark theme with proper contrast ratios\nProgressive Web App: Converting to PWA for offline access and mobile app-like experience"
  },
  {
    "objectID": "posts/first-post.html#conclusion",
    "href": "posts/first-post.html#conclusion",
    "title": "Building My Engineering Portfolio with Quarto",
    "section": "Conclusion",
    "text": "Conclusion\nBuilding this portfolio has been an exercise in applying engineering principles to web development. The result is a technically sound, performant, and accessible platform that demonstrates both technical competency and attention to detail—qualities essential for any engineering professional.\nThe combination of Quarto’s technical publishing capabilities with custom CSS and thoughtful UX design creates a portfolio that not only showcases work but also demonstrates the engineering mindset behind its creation.\n\nThis post represents the first in a series documenting the technical decisions and implementation details behind my engineering portfolio. Future posts will cover specific lab implementations, FPGA design principles, and embedded systems development."
  },
  {
    "objectID": "labs.html#labs",
    "href": "labs.html#labs",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Labs",
    "text": "Labs"
  },
  {
    "objectID": "labs.html#lab-documentation-resources",
    "href": "labs.html#lab-documentation-resources",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Lab Documentation & Resources",
    "text": "Lab Documentation & Resources"
  },
  {
    "objectID": "index.html#engineering-student-technical-innovator",
    "href": "index.html#engineering-student-technical-innovator",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Engineering Student & Technical Innovator",
    "text": "Engineering Student & Technical Innovator"
  },
  {
    "objectID": "index.html#featured-work",
    "href": "index.html#featured-work",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Featured Work",
    "text": "Featured Work"
  },
  {
    "objectID": "index.html#about-me-1",
    "href": "index.html#about-me-1",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "About Me",
    "text": "About Me"
  },
  {
    "objectID": "resources.html#resources",
    "href": "resources.html#resources",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Resources",
    "text": "Resources"
  },
  {
    "objectID": "resources.html#online-resources",
    "href": "resources.html#online-resources",
    "title": "Emmett Stralka - Engineering Portfolio",
    "section": "Online Resources",
    "text": "Online Resources"
  }
]